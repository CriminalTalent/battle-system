<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Pyxis - 플레이어</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Socket.IO -->
  <script src="/socket.io/socket.io.js"></script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600;700&family=Inter:wght@400;600;700&display=swap" rel="stylesheet"/>

  <!-- PYXIS 공용 테마 & 파비콘 -->
  <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg">
  <link rel="stylesheet" href="/assets/pyxis-theme.css">

  <style>
    /* 페이지 전용 소량 보조 스타일 */
    .layout { display:grid; grid-template-columns: 1fr 1.2fr 1fr; gap:16px }
    @media (max-width: 1024px){ .layout { grid-template-columns: 1fr } }

    .team-col .title { margin-bottom:10px }
    .player-card.me { outline: 1px solid var(--gold-20); box-shadow: 0 0 0 2px var(--gold-10) inset; }
    .player-actions { display:grid; gap:8px; grid-template-columns: repeat(2, minmax(0,1fr)); margin-top:12px }
    .player-actions .btn-pass { grid-column: 1 / -1; }

    .center-col .title { display:flex; align-items:center; justify-content:space-between }
    .log { height: 46vh; min-height:280px; overflow:auto }
    @media (max-width: 1024px){ .log { height: 34vh } }

    .chatlog { height: 200px; overflow:auto }
    .chatbox { display:flex; gap:8px; margin-top:8px }

    /* 핀 공지 */
    .pin { margin-bottom:12px }
    .pin .badge { font-size:12px; padding:2px 8px; border-radius:999px; background:var(--gold-20); color:var(--ink); border:1px solid var(--gold-30); margin-right:6px }

    /* 타깃 선택 모달 */
    .modal { position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.45); z-index:1000 }
    .modal .list { display:grid; gap:8px; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)) }
    .modal .player-chip { display:flex; align-items:center; gap:10px; padding:10px; border:1px solid var(--border-1); border-radius:12px; background:var(--panel-2); cursor:pointer }
    .modal .player-chip:hover { border-color: var(--gold-30) }
    .chip-ring { width:34px; height:34px; border-radius:50%; border:1px solid var(--border-1); background: var(--avatar,linear-gradient(135deg,var(--panel-2),var(--panel-3))) center/cover no-repeat }
    .hp-mini { font-size:12px; color:var(--text-dim) }

    /* 상태 바 작은 표시 */
    .tiny { font-size:12px; color:var(--text-dim) }
  </style>
</head>
<body>
  <div class="container">
    <!-- 헤더 -->
    <section class="hero">
      <h1 class="hero-title">Pyxis 전투 아레나</h1>
      <div class="muted" id="serverLine">서버 상태 확인 중...</div>
    </section>

    <!-- 상태 바 -->
    <div class="status">
      <div class="item">전투 상태: <b id="bStatus">-</b></div>
      <div class="item">라운드/턴: <b id="bRT">-</b></div>
      <div class="item">현재 팀: <b id="bTeam">-</b></div>
      <div class="item">내 상태: <b id="myState">-</b></div>
    </div>

    <!-- 핀 공지 -->
    <div id="pinWrap" class="notice pin hidden">
      <div class="notice-title"><span class="badge">공지</span><span id="pinTitle">관리자 공지</span></div>
      <div id="pinBody" class="notice-body"></div>
    </div>

    <!-- 인증 카드 -->
    <section id="authCard" class="card">
      <div class="title">전투 입장</div>
      <div class="row">
        <div>
          <div class="muted">전투 ID</div>
          <input id="inpBattle" class="input" placeholder="battle id" />
        </div>
        <div>
          <div class="muted">플레이어 OTP</div>
          <input id="inpOtp" class="input" placeholder="player otp" />
        </div>
      </div>
      <div class="row">
        <div>
          <div class="muted">이름</div>
          <input id="inpName" class="input" placeholder="플레이어 이름" />
        </div>
        <div>
          <div class="muted">팀</div>
          <select id="inpTeam" class="select">
            <option value="team1">team1</option>
            <option value="team2">team2</option>
          </select>
        </div>
      </div>
      <div class="row">
        <button id="btnJoin" class="btn">입장</button>
        <button id="btnPrefill" class="btn-ghost">URL로 자동입력</button>
      </div>
      <div class="muted tiny">※ 스탯/아이템은 관리자 페이지에서만 설정합니다. 여기선 입력하지 않습니다.</div>
    </section>

    <!-- 메인 레이아웃 -->
    <div id="main" class="hidden layout">
      <!-- 좌: 팀1 -->
      <div class="team-col">
        <div class="title">팀 1</div>
        <div id="team1"></div>
      </div>

      <!-- 중앙: 로그 & 채팅 -->
      <div class="center-col">
        <section class="card">
          <div class="title">
            <span>전투 로그</span>
            <span id="turnHint" class="tiny">-</span>
          </div>
          <div id="battleLog" class="log"></div>
        </section>

        <section class="card">
          <div class="title">채팅</div>
          <div id="chatLog" class="chatlog"></div>
          <div class="chatbox">
            <input id="chatInput" class="input" placeholder="메시지 입력…" />
            <button id="btnSendChat" class="btn">보내기</button>
          </div>
          <div class="tiny" style="margin-top:6px">관리자 메시지는 하이라이트로 표시됩니다.</div>
        </section>
      </div>

      <!-- 우: 팀2 -->
      <div class="team-col">
        <div class="title">팀 2</div>
        <div id="team2"></div>
      </div>
    </div>
  </div>

  <!-- 타깃 선택 모달 -->
  <div id="targetModal" class="modal hidden">
    <div class="card" style="width:min(720px,92vw)">
      <div class="title" id="targetTitle">대상 선택</div>
      <div id="targetList" class="list"></div>
      <div style="display:flex; gap:8px; margin-top:12px; justify-content:flex-end">
        <button id="btnCloseTarget" class="btn-ghost">닫기</button>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const $ = (s)=>document.querySelector(s);

      // Elements
      const serverLine = $('#serverLine');
      const bStatus = $('#bStatus'), bRT = $('#bRT'), bTeam = $('#bTeam'), myState = $('#myState');
      const pinWrap = $('#pinWrap'), pinTitle = $('#pinTitle'), pinBody = $('#pinBody');

      const authCard = $('#authCard'), main = $('#main');
      const inpBattle = $('#inpBattle'), inpOtp = $('#inpOtp'), inpName = $('#inpName'), inpTeam = $('#inpTeam');
      const btnJoin = $('#btnJoin'), btnPrefill = $('#btnPrefill');

      const team1Div = $('#team1'), team2Div = $('#team2');
      const battleLog = $('#battleLog'), chatLog = $('#chatLog'), chatInput = $('#chatInput'), btnSendChat = $('#btnSendChat');
      const turnHint = $('#turnHint');

      const targetModal = $('#targetModal'), targetTitle = $('#targetTitle'), targetList = $('#targetList'), btnCloseTarget = $('#btnCloseTarget');

      // State
      let socket = null;
      let battleId = null;
      let playerId = null;
      let playerOtp = null;
      let me = null;      // 내 플레이어 객체
      let battle = null;  // 전체 전투 상태
      let pendingAction = null; // { type, itemType? }

      // Utils
      function qs(){
        const p = new URLSearchParams(location.search);
        return {
          battle: p.get('battle') || p.get('b'),
          token: p.get('token') || p.get('otp') || p.get('t'),
          name: p.get('name') || p.get('n'),
          team: p.get('team') || p.get('side') || null,
        };
      }
      function fmtTime(ts){ try{ return new Date(ts).toLocaleTimeString(); } catch { return '-'; } }
      function esc(s=''){ return s.replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])) }
      function setServerLine(ok,msg){ serverLine.textContent = ok? `서버 OK · ${msg||''}` : `서버 오류 · ${msg||''}`; serverLine.className = ok? 'muted':'pill'; }
      function isMyTurn(){
        if(!battle || !me) return false;
        return (battle.currentTeam === me.team) && battle.status === 'ongoing';
      }
      function hpPct(p){ if(!p) return 0; return Math.max(0, Math.min(100, Math.round((p.hp / p.maxHp)*100))) }

      // Render
      function renderBattle(b){
        battle = b;
        if(!b) return;

        // 상태바
        bStatus.textContent = b.status || '-';
        bTeam.textContent = b.currentTeam || '-';
        bRT.textContent = `${b.roundNumber ?? '-'} / ${b.turnNumber ?? '-'}`;

        // 내 상태
        if(me){
          const pct = hpPct(me);
          myState.textContent = `${me.alive ? '생존' : '사망'} · HP ${me.hp}/${me.maxHp} (${pct}%)`;
        } else {
          myState.textContent = '-';
        }

        turnHint.textContent = isMyTurn() ? '당신 팀의 턴입니다.' : '상대 팀의 턴입니다.';

        // 핀 공지: 최근 관리자 메시지 중 "[공지]" 접두가 있는 가장 마지막 항목을 표시
        const adminNotice = (b.chatLog||[]).slice().reverse().find(m => (m.senderType==='admin') && (m.message||'').trim().startsWith('[공지]'));
        if(adminNotice){
          pinWrap.classList.remove('hidden');
          pinBody.textContent = adminNotice.message.replace(/^\[공지\]\s*/,'');
        } else {
          pinWrap.classList.add('hidden');
        }

        // 팀 렌더
        drawTeam('team1', b.teams?.team1, team1Div);
        drawTeam('team2', b.teams?.team2, team2Div);

        // 로그
        battleLog.innerHTML = (b.battleLog||[]).map(e=>{
          const cls = e.type === 'system' ? 'll admin' : 'll';
          return `<div class="${cls}"><span class="t">${fmtTime(e.timestamp)}</span>${esc(e.message||'')}</div>`;
        }).join('');
        battleLog.scrollTop = battleLog.scrollHeight;

        // 채팅
        chatLog.innerHTML = (b.chatLog||[]).map(c=>{
          const tag = c.senderType==='admin' ? '<span class="tag tag-admin">ADMIN</span>' : '<span class="tag">CHAT</span>';
          return `<div class="msg"><span class="t">${fmtTime(c.timestamp)}</span>${tag} <b>${esc(c.sender||'-')}</b>: ${esc(c.message||'')}</div>`;
        }).join('');
        chatLog.scrollTop = chatLog.scrollHeight;
      }

      function drawTeam(key, team, mount){
        if(!team){ mount.innerHTML = '<div class="muted">팀 없음</div>'; return; }
        const players = team.players || [];
        mount.innerHTML = players.map(p=>{
          const pct = hpPct(p);
          const isMe = me && p.id === me.id;
          const ringStyle = `--hp:${pct}; --avatar:url('${esc(p.imageUrl||'')}')`;
          return `
            <div class="player-card ${isMe?'me':''}">
              <div class="pc-head">
                <div class="pc-name">${esc(p.name||'플레이어')}${p.alive===false?' <span class="pill">사망</span>':''}</div>
                <div class="pc-meta tiny">${p.alive!==false? `HP ${p.hp}/${p.maxHp}` : '행동 불가'}</div>
              </div>
              <div class="pc-body">
                <div class="pc-ring" style="${ringStyle}">
                  <div class="pc-ring-inner"></div>
                </div>
                <div class="pc-hp">
                  <div class="hpbar"><div class="fill" style="--hpPct:${pct}%;"></div></div>
                  <div class="pct">${pct}%</div>
                </div>
                <div class="pc-stats">
                  <div><b>ATK</b> ${p.stats?.attack ?? '-'}</div>
                  <div><b>DEF</b> ${p.stats?.defense ?? '-'}</div>
                  <div><b>AGI</b> ${p.stats?.agility ?? '-'}</div>
                  <div><b>LUCK</b> ${p.stats?.luck ?? '-'}</div>
                </div>
              </div>
              ${isMe ? renderActionsBlock(p) : ''}
            </div>
          `;
        }).join('');
        // 액션 버튼 핸들러 다시 바인딩
        if(me){ bindActionButtons(); }
      }

      function renderActionsBlock(p){
        const canAct = isMyTurn() && p.alive !== false && !p.hasActed;
        const inv = Array.isArray(p.inventory) ? p.inventory : [];
        return `
          <div class="ready-row" style="margin-top:8px">
            <button id="btnReady" class="ready-btn${p.isReady?' ready-btn--on':''}" ${battle?.status!=='waiting'?'disabled':''}>
              ${p.isReady?'준비 완료':'전투 준비'}
            </button>
          </div>
          <div class="player-actions">
            <button class="btn" data-act="attack" ${!canAct?'disabled':''}>공격</button>
            <button class="btn" data-act="defend" ${!canAct?'disabled':''}>방어</button>
            <button class="btn" data-act="dodge" ${!canAct?'disabled':''}>회피</button>
            <button class="btn" data-act="item" ${(!canAct||inv.length===0)?'disabled':''}>아이템</button>
            <button class="btn btn-pass" data-act="pass" ${!canAct?'disabled':''}>턴 넘기기</button>
          </div>
          <div class="pc-items tiny" style="margin-top:8px">
            소지 아이템: ${inv.length? inv.map(esc).join(', ') : '없음'}
          </div>
        `;
      }

      function bindActionButtons(){
        const btnReady = document.getElementById('btnReady');
        if(btnReady){
          btnReady.onclick = ()=>{
            // 서버에 별도 API 없음 → 채팅으로 신호만 보냄
            if(socket) socket.emit('chatMessage', { message: `[READY] ${me?.name||''}` });
          };
        }
        document.querySelectorAll('.player-actions .btn').forEach(b=>{
          b.onclick = ()=>{
            const act = b.getAttribute('data-act');
            if(!act) return;
            handleAction(act);
          };
        });
      }

      // 액션 처리
      async function handleAction(type){
        if(!socket || !battleId || !playerId) return alert('연결되지 않았습니다.');
        if(!me || me.alive===false) return;

        if(type === 'attack'){
          // 1:1이면 상대 자동, 2:2 이상이면 타깃 선택
          const enemyKey = me.team === 'team1' ? 'team2' : 'team1';
          const candidates = (battle?.teams?.[enemyKey]?.players || []).filter(x=>x.alive!==false);
          if(candidates.length === 0) return;
          if(candidates.length === 1){
            emitAction({ type:'attack', targetId: candidates[0].id });
          } else {
            pendingAction = { type:'attack' };
            openTargetPicker('공격 대상 선택', candidates, (t)=> emitAction({ type:'attack', targetId: t.id }));
          }
          return;
        }

        if(type === 'item'){
          const inv = Array.isArray(me.inventory) ? me.inventory.slice() : [];
          if(inv.length === 0) return;
          // 간단한 아이템 선택 UI (prompt 대체)
          const pick = await pickItem(inv);
          if(!pick) return;

          if(pick === '디터니'){
            // 아군(자신 포함) 선택 필요
            const allies = (battle?.teams?.[me.team]?.players || []).filter(x=>x.alive!==false);
            if(allies.length === 1){
              emitAction({ type:'item', itemType: '디터니', targetId: allies[0].id });
            } else {
              pendingAction = { type:'item', itemType:'디터니' };
              openTargetPicker('회복 대상 선택', allies, (t)=> emitAction({ type:'item', itemType:'디터니', targetId: t.id }));
            }
          } else if(pick === '공격 보정기' || pick === '방어 보정기'){
            // 자기 자신에게 사용
            emitAction({ type:'item', itemType: pick, targetId: me.id });
          } else {
            alert('알 수 없는 아이템 유형입니다.');
          }
          return;
        }

        if(['defend','dodge','pass'].includes(type)){
          emitAction({ type });
          return;
        }

        alert('지원하지 않는 액션입니다.');
      }

      function emitAction(action){
        socket.emit('playerAction', { battleId, playerId, action });
        closeTargetPicker();
      }

      // 아이템 간단 선택(카드 안 옵션)
      function pickItem(inv){
        return new Promise((resolve)=>{
          // 작은 모달 재사용: 리스트를 아이템으로 채움
          targetTitle.textContent = '아이템 선택';
          targetList.innerHTML = inv.map((name, idx)=>`
            <div class="player-chip" data-idx="${idx}" data-name="${esc(name)}">
              <div class="chip-ring" style="--avatar:url('/assets/item.svg')"></div>
              <div>
                <div><b>${esc(name)}</b></div>
                <div class="hp-mini">사용 대상 선택이 필요할 수 있습니다</div>
              </div>
            </div>
          `).join('');
          targetList.querySelectorAll('.player-chip').forEach(el=>{
            el.onclick = ()=> { resolve(el.getAttribute('data-name')); closeTargetPicker(); };
          });
          targetModal.classList.remove('hidden');
          btnCloseTarget.onclick = ()=> { resolve(null); closeTargetPicker(); };
        });
      }

      // 타깃 선택 모달
      function openTargetPicker(title, players, onPick){
        targetTitle.textContent = title;
        targetList.innerHTML = players.map(p=>{
          const pct = hpPct(p);
          return `
            <div class="player-chip" data-id="${p.id}">
              <div class="chip-ring" style="--avatar:url('${esc(p.imageUrl||'')}')"></div>
              <div>
                <div><b>${esc(p.name||'-')}</b></div>
                <div class="hp-mini">HP ${p.hp}/${p.maxHp} · ${pct}%</div>
              </div>
            </div>
          `;
        }).join('');
        targetList.querySelectorAll('.player-chip').forEach(el=>{
          el.onclick = ()=> {
            const id = el.getAttribute('data-id');
            const t = players.find(x=>x.id===id);
            if(!t) return;
            onPick(t);
          };
        });
        targetModal.classList.remove('hidden');
        btnCloseTarget.onclick = closeTargetPicker;
      }
      function closeTargetPicker(){
        targetModal.classList.add('hidden');
        targetList.innerHTML = '';
        pendingAction = null;
      }

      // 채팅
      btnSendChat.onclick = ()=>{
        const msg = chatInput.value.trim();
        if(!msg) return;
        if(!socket) return alert('연결되지 않았습니다.');
        // 서버는 { message }만 처리
        socket.emit('chatMessage', { message: msg });
        chatInput.value = '';
      };

      // 서버 헬스
      fetch('/api/health').then(r=>r.json()).then(j=>{
        setServerLine(true, `활성 전투: ${j.battles}`);
      }).catch(()=> setServerLine(false, '헬스 체크 실패'));

      // 인증/입장
      btnPrefill.onclick = ()=>{
        const p = qs();
        if(p.battle) inpBattle.value = p.battle;
        if(p.token)  inpOtp.value = p.token;
        if(p.name)   inpName.value = p.name;
        if(p.team)   inpTeam.value = p.team;
      };

      btnJoin.onclick = async ()=>{
        const id = inpBattle.value.trim();
        const otp = inpOtp.value.trim();
        const name = inpName.value.trim();
        const team = inpTeam.value;

        if(!id || !otp || !name || !team){ alert('모든 필드를 입력하세요.'); return; }

        battleId = id;
        playerOtp = otp;

        try{
          // 1) 내 플레이어 생성 시도 (중복 이름이면 서버에서 거절)
          let created = null;
          try{
            const r = await fetch(`/api/battles/${encodeURIComponent(battleId)}/players`, {
              method:'POST',
              headers:{ 'Content-Type':'application/json' },
              body: JSON.stringify({ name, team })
            });
            if(r.ok){
              const data = await r.json();
              created = data.player;
            } else {
              // 생성 실패 시도는 무시하고 다음 단계로(아마 중복 이름)
            }
          }catch(_){}

          // 2) 전투 상태 조회 후, 이름으로 내 id 식별
          const b = await (await fetch(`/api/battles/${encodeURIComponent(battleId)}`)).json();
          battle = b;
          const all = [...(b.teams?.team1?.players||[]), ...(b.teams?.team2?.players||[])];
          const mine = created || all.find(p=> p.name === name && p.team === team);
          if(!mine){ alert('해당 이름/팀의 플레이어를 찾지 못했습니다. 관리자에게 문의하세요.'); return; }
          playerId = mine.id;
          me = mine;

          // 3) 소켓 연결 + 플레이어 인증
          connectSocket();
          authCard.classList.add('hidden');
          main.classList.remove('hidden');
          renderBattle(battle);
        }catch(e){
          alert('입장 실패: ' + (e.message||e));
        }
      };

      // 소켓
      function connectSocket(){
        if(socket){ try{ socket.disconnect(); }catch{} socket=null; }
        socket = io({ path:'/socket.io/', transports:['websocket','polling'] });

        socket.on('connect', ()=>{
          socket.emit('playerAuth', { battleId, otp: playerOtp, playerId });
        });

        socket.on('authSuccess', ({ battle: b, player })=>{
          battle = b;
          if(player) me = player;
          // 최신 me 동기화
          const found = findMeIn(b);
          if(found) me = found;
          renderBattle(battle);
        });

        socket.on('authError', (msg)=>{
          alert('플레이어 인증 실패: ' + (msg||''));
        });

        socket.on('battleUpdate', (b)=>{
          // 내 객체 갱신
          const found = findMeIn(b);
          if(found) me = found;
          renderBattle(b);
        });

        socket.on('connect_error', (e)=> console.warn('socket error', e?.message||e));
      }

      function findMeIn(b){
        const all = [...(b?.teams?.team1?.players||[]), ...(b?.teams?.team2?.players||[])];
        return all.find(p=> p.id === playerId) || null;
      }

      // 부팅: 쿼리 자동반영(있으면)
      (function boot(){
        const p = qs();
        if(p.battle) inpBattle.value = p.battle;
        if(p.token)  inpOtp.value = p.token;
        if(p.name)   inpName.value = p.name;
        if(p.team)   inpTeam.value = p.team;
      })();

    })();
  </script>
</body>
</html>
