<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PYXIS 플레이어</title>
<link rel="icon" type="image/svg+xml" href="/assets/favicon.svg">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700;800;900&family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<link href="/assets/pyxis-theme.css" rel="stylesheet">
<script src="/socket.io/socket.io.js"></script>
<style>
/* 플레이어 전용 스타일 - 관리자 페이지 디자인과 통일 */
.player-header{
  position:relative; 
  padding:32px 20px 16px; 
  overflow:hidden;
}
.player-header::before{
content:'';
position:absolute;
inset:-40% -16% auto -16%;
height:360px;
background:conic-gradient(from 0deg at 50% 50%,
rgba(212,183,126,.18) 0deg,
rgba(212,183,126,.06) 60deg,
rgba(212,183,126,.22) 120deg,
rgba(212,183,126,.04) 180deg,
rgba(212,183,126,.18) 240deg,
rgba(212,183,126,.06) 300deg,
rgba(212,183,126,.18) 360deg
);
filter:blur(60px);
animation:playerOrbit 45s linear infinite;
opacity:.7;
pointer-events:none;
z-index:-1;
}
@keyframes playerOrbit{
0%{transform:rotate(0deg) scale(1)}
25%{transform:rotate(90deg) scale(1.08)}
50%{transform:rotate(180deg) scale(.92)}
75%{transform:rotate(270deg) scale(1.12)}
100%{transform:rotate(360deg) scale(1)}
}
.player-brand{
font-family:var(--serif);
font-weight:900;
letter-spacing:.08em;
font-size:36px;
background:linear-gradient(135deg,
var(--gold-bright) 0%,
var(--gold-shimmer) 25%,
var(--gold) 50%,
var(--gold-light) 75%,
var(--gold-bright) 100%
);
background-size:350% 350%;
-webkit-background-clip:text;
background-clip:text;
-webkit-text-fill-color:transparent;
animation:playerShimmer 4s ease-in-out infinite;
position:relative;
display:inline-block;
text-shadow:0 4px 18px rgba(212,183,126,.35);
}
@keyframes playerShimmer{
0%,100%{
background-position:0% 50%;
filter:brightness(1);
transform:scale(1);
}
50%{
background-position:100% 50%;
filter:brightness(1.2);
transform:scale(1.025);
}
}
.player-brand::before{
content:'✦';
position:absolute;
top:-8px;
left:-22px;
font-size:16px;
color:var(--gold);
animation:twinkle 2s ease-in-out infinite;
opacity:.8;
}
.player-brand::after{
content:'전투자';
position:absolute;
top:-8px;
right:-58px;
font-size:12px;
font-weight:700;
color:var(--gold);
background:linear-gradient(135deg, rgba(212,183,126,.2), rgba(212,183,126,.1));
border:1px solid var(--gold);
border-radius:999px;
padding:4px 12px;
letter-spacing:.02em;
box-shadow:0 3px 10px rgba(212,183,126,.15);
}
@keyframes twinkle{
0%,100%{ opacity:.3; transform:scale(.8) rotate(0deg); }
50%{ opacity:1; transform:scale(1.2) rotate(180deg); }
}
.player-stage{
display:grid;
grid-template-columns:280px 1fr 340px;
gap:20px;
padding:18px 22px;
max-width:1500px;
margin:0 auto;
}
@media (max-width:1300px){
.player-stage{
grid-template-columns:1fr;
gap:16px;
}
}
/* 인증 섹션 - 관리자 스타일 적용 */
.auth-section{
background:linear-gradient(
145deg,
rgba(212,183,126,.08) 0%,
rgba(16,21,35,.88) 30%,
rgba(26,32,44,.82) 100%
);
border:2px solid var(--gold);
border-radius:var(--radius);
padding:24px;
text-align:center;
backdrop-filter:var(--blur-strong);
box-shadow:var(--shadow-deep), inset 0 2px 0 rgba(212,183,126,.2), var(--shadow-glow);
position:relative;
overflow:hidden;
}
.auth-section::before{
content:'';
position:absolute;
inset:0;
background:linear-gradient(
135deg,
rgba(212,183,126,.1),
transparent 40%,
rgba(212,183,126,.05)
);
opacity:.6;
}
.auth-title{
font-family:var(--serif);
font-size:26px;
font-weight:800;
color:var(--gold-bright);
margin-bottom:18px;
position:relative;
text-shadow:0 2px 8px rgba(212,183,126,.3);
}
.auth-form{
display:grid;
gap:14px;
max-width:420px;
margin:0 auto;
position:relative;
}
.auth-row{
display:grid;
grid-template-columns:1fr 1fr;
gap:12px;
}
@media (max-width:600px){
.auth-row{
grid-template-columns:1fr;
}
}
/* 중앙 섹션 */
.center-section{
display:grid;
grid-template-rows:auto 1fr auto;
gap:16px;
min-height:650px;
}
.player-info-bar{
background:linear-gradient(
145deg,
rgba(16,21,35,.92) 0%,
rgba(26,32,44,.88) 50%,
rgba(16,21,35,.92) 100%
);
border:1px solid var(--border-2);
border-radius:var(--radius);
padding:20px;
backdrop-filter:var(--blur-medium);
box-shadow:var(--shadow-medium), var(--shadow-inset), var(--shadow-glow);
position:relative;
}
.player-info-bar::before{
content:'';
position:absolute;
top:0; left:24px; right:24px; height:1px;
background:linear-gradient(
90deg,
transparent,
var(--gold-subtle) 40%,
var(--gold) 50%,
var(--gold-subtle) 60%,
transparent
);
opacity:.8;
}
.info-header{
display:flex;
justify-content:space-between;
align-items:center;
margin-bottom:14px;
}
.player-name{
font-family:var(--serif);
font-size:24px;
font-weight:800;
color:var(--gold-bright);
text-shadow:0 2px 8px rgba(212,183,126,.3);
}
.player-team{
font-size:13px;
color:var(--text-dim);
font-weight:600;
padding:5px 14px;
background:rgba(212,183,126,.1);
border:1px solid rgba(212,183,126,.3);
border-radius:999px;
letter-spacing:.01em;
}
.turn-status{
font-size:16px;
font-weight:700;
padding:8px 18px;
border-radius:999px;
border:1px solid var(--border-1);
background:rgba(26,32,44,.8);
color:var(--text-dim);
transition:all var(--transition-normal);
backdrop-filter:var(--blur-light);
}
.turn-status.active{
background:linear-gradient(135deg, var(--gold-bright), var(--gold-dark));
color:var(--deep-navy);
border-color:var(--gold-bright);
box-shadow:0 0 18px rgba(212,183,126,.5), 0 0 8px rgba(212,183,126,.3) inset;
animation:turnPulse 2.5s ease-in-out infinite;
font-weight:800;
}
@keyframes turnPulse{
0%,100%{
box-shadow:0 0 18px rgba(212,183,126,.5), 0 0 8px rgba(212,183,126,.3) inset
}
50%{
box-shadow:0 0 26px rgba(212,183,126,.7), 0 0 12px rgba(212,183,126,.5) inset
}
}
.action-bar{
display:flex;
gap:12px;
flex-wrap:wrap;
justify-content:center;
margin-top:12px;
}
.action-btn{
padding:14px 20px;
font-size:14px;
font-weight:700;
border-radius:var(--radius-small);
border:2px solid var(--border-2);
background:linear-gradient(
145deg,
rgba(42,52,65,.9),
rgba(26,32,44,.9)
);
color:var(--text);
cursor:pointer;
transition:all var(--transition-normal);
position:relative;
overflow:hidden;
min-width:90px;
backdrop-filter:var(--blur-light);
box-shadow:var(--shadow-subtle);
}
.action-btn::before{
content:'';
position:absolute;
inset:0;
background:linear-gradient(
135deg,
rgba(212,183,126,.15),
transparent 50%,
rgba(212,183,126,.1)
);
opacity:0;
transition:opacity var(--transition-normal);
}
.action-btn:hover:not(:disabled){
transform:translateY(-3px);
border-color:var(--gold);
box-shadow:var(--shadow-medium), 0 0 20px rgba(212,183,126,.25);
color:var(--gold-bright);
}
.action-btn:hover:not(:disabled)::before{
opacity:1;
}
.action-btn:disabled{
opacity:.4;
cursor:not-allowed;
transform:none;
}
.action-btn.primary{
background:linear-gradient(145deg, var(--gold-bright), var(--gold-dark));
color:var(--deep-navy);
border-color:var(--gold);
font-weight:800;
box-shadow:var(--shadow-soft), 0 0 15px rgba(212,183,126,.2);
}
.action-btn.primary:hover:not(:disabled){
background:linear-gradient(145deg, var(--gold-shimmer), var(--gold));
box-shadow:var(--shadow-medium), 0 0 25px rgba(212,183,126,.4);
transform:translateY(-3px) scale(1.02);
}
.game-hint{
text-align:center;
color:var(--text-muted);
font-size:13px;
font-style:italic;
margin-top:12px;
padding:10px;
background:rgba(212,183,126,.05);
border-radius:var(--radius-small);
border:1px solid rgba(212,183,126,.1);
backdrop-filter:var(--blur-light);
}
.game-hint.active{
color:var(--gold-bright);
background:rgba(212,183,126,.12);
border-color:rgba(212,183,126,.3);
font-weight:600;
font-style:normal;
}
/* 전투 초상화 */
.battle-portrait{
position:relative;
min-height:340px;
display:flex;
align-items:flex-end;
justify-content:center;
border:1px solid var(--border-1);
border-radius:var(--radius-large);
background:
radial-gradient(circle at 30% 20%, rgba(212,183,126,.08), transparent 60%),
radial-gradient(circle at 70% 80%, rgba(212,183,126,.04), transparent 50%),
linear-gradient(180deg, rgba(5,20,38,.92), rgba(7,28,48,.96), rgba(10,33,56,.92));
overflow:hidden;
backdrop-filter:var(--blur-light);
box-shadow:var(--shadow-medium), var(--shadow-inset);
}
.portrait-character{
position:absolute;
bottom:0;
width:min(44%, 320px);
aspect-ratio:3/4;
background:linear-gradient(135deg, var(--midnight), var(--navy-mist)) center/contain no-repeat;
border:2px solid var(--border-1);
border-radius:14px 14px 0 0;
box-shadow:var(--shadow-medium), inset 0 2px 0 rgba(255,255,255,.05);
transition:all .4s var(--ease-smooth);
filter:brightness(.88);
}
.portrait-character.left{ left:8%; }
.portrait-character.right{ right:8%; }
.portrait-character.active{
transform:translateY(-4px) scale(1.02);
border-color:var(--gold-bright);
filter:brightness(1.1);
box-shadow:
var(--shadow-deep),
0 0 0 3px rgba(212,183,126,.5),
0 0 25px rgba(212,183,126,.3),
inset 0 2px 0 rgba(255,255,255,.1);
animation:championGlow 4s ease-in-out infinite;
}
@keyframes championGlow{
0%,100%{
box-shadow:
var(--shadow-deep),
0 0 0 3px rgba(212,183,126,.5),
0 0 25px rgba(212,183,126,.3),
inset 0 2px 0 rgba(255,255,255,.1)
}
50%{
box-shadow:
var(--shadow-deep),
0 0 0 4px rgba(212,183,126,.7),
0 0 35px rgba(212,183,126,.5),
inset 0 2px 0 rgba(255,255,255,.15)
}
}
.portrait-stats{
position:absolute;
bottom:18px; left:18px; right:18px;
display:flex;
gap:16px;
flex-wrap:wrap;
color:var(--text);
font-size:14px;
font-weight:600;
background:rgba(10,33,56,.95);
border:1px solid var(--border-1);
border-radius:12px;
padding:14px 18px;
backdrop-filter:var(--blur-medium);
box-shadow:var(--shadow-soft);
}
.stat-item{
display:flex;
align-items:center;
gap:8px;
}
.stat-label{
color:var(--text-muted);
font-size:12px;
}
.stat-value{
color:var(--gold-bright);
font-weight:800;
}
/* 사이드 패널 */
.team-panel{
display:flex;
flex-direction:column;
gap:14px;
}
.team-header{
text-align:center;
font-family:var(--serif);
font-weight:800;
font-size:17px;
color:var(--gold-bright);
padding:12px 18px;
background:linear-gradient(
135deg,
rgba(212,183,126,.15),
rgba(212,183,126,.08)
);
border:1px solid var(--border-1);
border-radius:var(--radius);
position:relative;
text-shadow:0 2px 6px rgba(212,183,126,.3);
box-shadow:var(--shadow-subtle);
}
.team-header::before{
content:'';
position:absolute;
top:0; left:25%; right:25%; height:1px;
background:linear-gradient(90deg, transparent, var(--gold-bright), transparent);
}
.unit{
display:flex;
gap:14px;
align-items:center;
border:1px solid var(--border-1);
border-radius:var(--radius);
padding:12px;
background:rgba(16,21,35,.8);
transition:all var(--transition-normal);
position:relative;
box-shadow:var(--shadow-subtle);
backdrop-filter:var(--blur-light);
}
.unit::before{
content:'';
position:absolute;
inset:0;
background:linear-gradient(
135deg,
transparent,
rgba(212,183,126,.04),
transparent
);
opacity:0;
transition:opacity var(--transition-normal);
border-radius:inherit;
}
.unit:hover{
border-color:var(--border-2);
transform:translateY(-2px);
box-shadow:var(--shadow-soft), var(--shadow-glow);
}
.unit:hover::before{
opacity:1;
}
.unit.active{
border-color:var(--gold);
background:rgba(212,183,126,.08);
box-shadow:
var(--shadow-soft),
0 0 0 1px rgba(212,183,126,.3),
var(--shadow-glow);
animation:activeUnit 3s ease-in-out infinite;
}
@keyframes activeUnit{
0%,100%{
box-shadow:
var(--shadow-soft),
0 0 0 1px rgba(212,183,126,.3),
var(--shadow-glow)
}
50%{
box-shadow:
var(--shadow-soft),
0 0 0 2px rgba(212,183,126,.5),
0 0 20px rgba(212,183,126,.25)
}
}
.unit.dead{
opacity:.5;
filter:grayscale(.8);
border-style:dashed;
}
.unit-avatar{
width:54px;
height:54px;
border-radius:var(--radius-small);
background:linear-gradient(135deg, var(--midnight), var(--navy-mist)) center/cover no-repeat;
border:2px solid var(--border-1);
position:relative;
overflow:hidden;
box-shadow:var(--shadow-subtle);
}
.unit-avatar::after{
content:'';
position:absolute;
inset:0;
background:linear-gradient(
135deg,
transparent 20%,
rgba(212,183,126,.08) 80%
);
opacity:.8;
}
.unit-info{
flex:1;
min-width:0;
}
.unit-name{
font-weight:800;
color:var(--text);
margin-bottom:6px;
font-size:15px;
}
.unit-name.dead::after{
content:' (불능)';
color:var(--text-muted);
font-weight:400;
font-size:13px;
}
.unit-hp{
height:8px;
background:rgba(26,31,42,.9);
border-radius:4px;
overflow:hidden;
margin:6px 0;
position:relative;
box-shadow:inset 0 1px 3px rgba(0,0,0,.3);
}
.unit-hp::after{
content:'';
position:absolute;
inset:0;
background:linear-gradient(90deg, rgba(255,255,255,.15), transparent 40%);
pointer-events:none;
}
.unit-hp-bar{
display:block;
height:100%;
background:linear-gradient(90deg, var(--gold-dark), var(--gold-bright));
transition:width .6s var(--ease-smooth);
position:relative;
box-shadow:0 0 8px rgba(212,183,126,.4);
}
.unit-stats{
font-size:11px;
color:var(--text-muted);
line-height:1.4;
}
/* 채팅 패널 */
.chat-panel{
display:flex;
flex-direction:column;
height:100%;
min-height:600px;
}
.chat-header{
display:flex;
gap:12px;
align-items:center;
margin-bottom:14px;
}
.chat-channel{
min-width:90px;
font-size:13px;
padding:10px 12px;
font-weight:600;
}
.chat-input{
flex:1;
font-size:13px;
padding:10px 14px;
font-weight:500;
}
.chat-send{
padding:10px 18px;
font-size:13px;
font-weight:700;
}
.chat-messages{
flex:1;
background:linear-gradient(
145deg,
rgba(5,15,28,.96) 0%,
rgba(8,20,35,.93) 50%,
rgba(5,15,28,.96) 100%
);
border:1px solid var(--border-1);
border-radius:var(--radius);
padding:16px;
overflow-y:auto;
font-size:12px;
line-height:1.5;
min-height:240px;
backdrop-filter:var(--blur-light);
box-shadow:
inset 0 3px 10px rgba(0,0,0,.4),
inset 0 1px 0 rgba(255,255,255,.02),
var(--shadow-soft);
}
.chat-message{
display:flex;
gap:10px;
align-items:baseline;
margin-bottom:8px;
padding:6px 10px;
border-radius:var(--radius-small);
transition:background var(--transition-fast);
border-bottom:1px solid rgba(212,183,126,.03);
}
.chat-message:hover{
background:rgba(212,183,126,.06);
}
.chat-time{
font-size:10px;
color:var(--text-muted);
min-width:48px;
font-weight:600;
}
.chat-content{
flex:1;
color:var(--text-dim);
}
.chat-message.system .chat-content{
color:var(--gold-bright);
font-weight:600;
}
.chat-message.team .chat-content{
color:var(--info);
}
.chat-message.cheer .chat-content{
color:var(--success);
font-weight:600;
}
/* 전투 로그 */
.battle-log{
background:linear-gradient(
145deg,
rgba(5,15,28,.96) 0%,
rgba(8,20,35,.93) 50%,
rgba(5,15,28,.96) 100%
);
border:1px solid var(--border-1);
border-radius:var(--radius);
padding:16px;
height:200px;
overflow-y:auto;
font-size:12px;
line-height:1.5;
backdrop-filter:var(--blur-light);
box-shadow:
inset 0 3px 10px rgba(0,0,0,.4),
inset 0 1px 0 rgba(255,255,255,.02),
var(--shadow-soft);
}
.log-entry{
display:flex;
gap:10px;
align-items:baseline;
margin-bottom:8px;
padding:6px 10px;
border-radius:var(--radius-small);
transition:background var(--transition-fast);
}
.log-entry:hover{
background:rgba(212,183,126,.06);
}
.log-entry .time{
font-size:10px;
color:var(--text-muted);
min-width:48px;
font-weight:600;
}
.log-entry .content{
flex:1;
color:var(--text-dim);
}
.log-entry.action .content{
color:var(--text);
font-weight:600;
}
.log-entry.system .content{
color:var(--gold-bright);
font-weight:600;
}
/* 타겟 선택 오버레이 */
.target-overlay{
position:fixed;
inset:0;
display:none;
align-items:center;
justify-content:center;
background:rgba(0,0,0,.8);
z-index:1000;
backdrop-filter:blur(8px);
}
.target-panel{
width:min(650px, 90vw);
background:linear-gradient(
145deg,
rgba(16,21,35,.96) 0%,
rgba(26,32,44,.92) 50%,
rgba(16,21,35,.96) 100%
);
border:2px solid var(--gold);
border-radius:var(--radius-large);
padding:24px;
backdrop-filter:var(--blur-strong);
box-shadow:var(--shadow-deep), var(--shadow-glow);
animation:targetAppear .4s var(--ease-smooth);
}
@keyframes targetAppear{
from{
opacity:0;
transform:scale(.9) translateY(-30px)
}
to{
opacity:1;
transform:scale(1) translateY(0)
}
}
.target-title{
font-family:var(--serif);
font-size:22px;
font-weight:800;
color:var(--gold-bright);
text-align:center;
margin-bottom:20px;
text-shadow:0 2px 8px rgba(212,183,126,.3);
}
.target-list{
display:grid;
grid-template-columns:repeat(auto-fit, minmax(220px, 1fr));
gap:14px;
margin-bottom:20px;
}
.target-card{
border:1px solid var(--border-1);
border-radius:var(--radius);
padding:16px;
background:rgba(42,52,65,.7);
cursor:pointer;
transition:all var(--transition-normal);
text-align:center;
backdrop-filter:var(--blur-light);
box-shadow:var(--shadow-subtle);
}
.target-card:hover:not(.disabled){
border-color:var(--gold);
background:rgba(212,183,126,.1);
transform:translateY(-2px);
box-shadow:var(--shadow-soft), var(--shadow-glow);
}
.target-card.disabled{
opacity:.4;
cursor:not-allowed;
}
.target-name{
font-weight:700;
margin-bottom:6px;
color:var(--text);
}
.target-hp{
font-size:12px;
color:var(--text-muted);
}
.target-actions{
display:flex;
justify-content:center;
gap:14px;
}
/* 단축키 힌트 */
.hotkey-hint{
font-size:10px;
color:var(--text-muted);
margin-left:6px;
opacity:.7;
}
/* 스크롤바 커스터마이징 */
.chat-messages::-webkit-scrollbar,
.battle-log::-webkit-scrollbar{
width:8px;
}
.chat-messages::-webkit-scrollbar-track,
.battle-log::-webkit-scrollbar-track{
background:rgba(5,15,28,.8);
border-radius:4px;
}
.chat-messages::-webkit-scrollbar-thumb,
.battle-log::-webkit-scrollbar-thumb{
background:linear-gradient(to bottom, var(--gold), var(--gold-dark));
border-radius:4px;
border:1px solid rgba(0,0,0,.2);
}
.chat-messages::-webkit-scrollbar-thumb:hover,
.battle-log::-webkit-scrollbar-thumb:hover{
background:linear-gradient(to bottom, var(--gold-bright), var(--gold));
}
/* 특수 효과 - 관리자 페이지와 동일한 스타일 */
.sparkle-effect{
position:relative;
overflow:hidden;
}
.sparkle-effect::before{
content:'✧';
position:absolute;
top:12px;
right:16px;
color:var(--gold);
font-size:11px;
opacity:.5;
animation:sparkle 3.5s ease-in-out infinite;
}
@keyframes sparkle{
0%, 100%{
opacity:.2;
transform:scale(.7) rotate(0deg);
}
50%{
opacity:1;
transform:scale(1.3) rotate(180deg);
}
}
.enhance-hover{
position:relative;
overflow:hidden;
}
.enhance-hover::after{
content:'';
position:absolute;
top:0; left:-100%; right:100%; bottom:0;
background:linear-gradient(
90deg,
transparent,
rgba(212,183,126,.08),
transparent
);
transition:all .6s ease;
}
.enhance-hover:hover::after{
left:100%; right:-100%;
}
/* 연결 상태 표시 */
.connection-status{
position:fixed;
top:20px;
left:20px;
z-index:1000;
display:flex;
align-items:center;
gap:8px;
padding:8px 16px;
background:rgba(16,21,35,.9);
border:1px solid var(--border-1);
border-radius:999px;
font-size:12px;
font-weight:600;
backdrop-filter:var(--blur-medium);
box-shadow:var(--shadow-soft);
}
.connection-dot{
width:8px;
height:8px;
border-radius:50%;
background:var(--danger);
animation:connectionPulse 2s ease-in-out infinite;
}
.connection-dot.connected{
background:var(--success);
}
.connection-dot.connecting{
background:var(--warning);
}
@keyframes connectionPulse{
0%,100%{ opacity:.6; transform:scale(1); }
50%{ opacity:1; transform:scale(1.2); }
}
/* 피드백 애니메이션 - 관리자 페이지와 동일 */
.feedback-success{
background:linear-gradient(135deg, var(--success), #219a52) !important;
color:white !important;
border-color:var(--success) !important;
animation:feedbackPulse .8s var(--ease-bounce);
}
.feedback-error{
background:linear-gradient(135deg, var(--danger), #c0392b) !important;
color:white !important;
border-color:var(--danger) !important;
animation:feedbackShake .6s ease-in-out;
}
@keyframes feedbackPulse{
0%{ transform:scale(1); }
50%{ transform:scale(1.05); }
100%{ transform:scale(1); }
}
@keyframes feedbackShake{
0%, 100%{ transform:translateX(0); }
25%{ transform:translateX(-4px); }
75%{ transform:translateX(4px); }
}
/* 로딩 효과 */
.loading{
opacity:.6;
pointer-events:none;
position:relative;
}
.loading::after{
content:'';
position:absolute;
inset:0;
background:linear-gradient(
90deg,
transparent,
rgba(212,183,126,.12),
transparent
);
animation:shimmer 1.6s infinite;
border-radius:inherit;
}
@keyframes shimmer{
0%{ transform:translateX(-100%); }
100%{ transform:translateX(100%); }
}
/* 반응형 디자인 */
@media (max-width:768px){
.player-header{
padding:28px 16px 12px;
}
.player-stage{
padding:14px 18px;
gap:14px;
}
.player-brand{
font-size:30px;
}
.player-brand::after{
top:-6px;
right:-48px;
font-size:11px;
padding:3px 10px;
}
.action-bar{
justify-content:stretch;
}
.action-btn{
flex:1;
min-width:auto;
}
.portrait-stats{
flex-direction:column;
gap:10px;
}
.stat-item{
justify-content:space-between;
}
.target-list{
grid-template-columns:1fr;
}
.chat-header{
flex-direction:column;
gap:10px;
}
.chat-channel{
width:100%;
min-width:auto;
}
.connection-status{
top:10px;
left:10px;
padding:6px 12px;
font-size:11px;
}
}
@media (max-width:480px){
.player-header{
padding:24px 12px 10px;
}
.player-stage{
padding:12px 16px;
}
.player-brand{
font-size:26px;
}
.auth-section{
padding:20px;
}
.action-btn{
padding:12px 16px;
font-size:13px;
}
.portrait-character{
width:min(50%, 280px);
}
}
/* 접근성 개선 */
@media (prefers-reduced-motion: reduce){
.player-header::before,
.player-brand,
.player-brand::before,
.turnPulse,
.championGlow,
.activeUnit,
.sparkle,
.shimmer,
.connectionPulse{
animation:none;
}
.unit:hover,
.action-btn:hover:not(:disabled),
.target-card:hover:not(.disabled){
transform:none;
}
}
/* 숨김 유틸리티 */
.hide{
display:none !important;
}
</style>
</head>
<body>
<!-- 연결 상태 표시 -->
<div class="connection-status" id="connectionStatus">
  <div class="connection-dot" id="connectionDot"></div>
  <span id="connectionText">연결 중...</span>
</div>
<header class="player-header">
  <div class="wrap">
    <div class="player-brand sparkle-effect">Pyxis</div>
  </div>
</header>
<main class="wrap player-stage">
  <!-- 좌측: 팀 정보 -->
  <aside class="team-panel" id="leftTeam">
    <div class="team-header enhance-hover">아군</div>
    <div id="allyUnits"></div>
  </aside>
  <!-- 중앙: 메인 -->
  <section class="center-section">
    <!-- 인증 폼 -->
    <div class="card auth-section sparkle-effect" id="authSection" style="display:none">
      <div class="auth-title">전투 입장</div>
      <div class="auth-form">
        <div class="field">
          <label for="authBattleId">전투 ID</label>
          <input id="authBattleId" class="input enhance-hover" placeholder="battle_xxxxx" maxlength="50">
        </div>
        <div class="auth-row">
          <div class="field">
            <label for="authToken">플레이어 OTP</label>
            <input id="authToken" class="input enhance-hover" placeholder="인증 토큰" maxlength="50">
          </div>
          <div class="field">
            <label for="authName">플레이어 이름</label>
            <input id="authName" class="input enhance-hover" placeholder="캐릭터 이름" maxlength="20">
          </div>
        </div>
        <button id="authJoinBtn" class="btn btn-gold enhance-hover">전투 참가</button>
      </div>
    </div>
    <!-- 정보 바 -->
    <div class="player-info-bar card sparkle-effect">
      <div class="info-header">
        <div>
          <div class="player-name" id="playerName">-</div>
          <div class="player-team" id="playerTeam">-</div>
        </div>
        <div class="turn-status" id="turnStatus">대기중</div>
      </div>
      <div class="action-bar" id="actionBar">
        <button class="action-btn primary enhance-hover" id="btnAttack">공격<span class="hotkey-hint">[1]</span></button>
        <button class="action-btn enhance-hover" id="btnDefend">방어<span class="hotkey-hint">[2]</span></button>
        <button class="action-btn enhance-hover" id="btnDodge">회피<span class="hotkey-hint">[3]</span></button>
        <button class="action-btn enhance-hover" id="btnUseItem">아이템<span class="hotkey-hint">[4]</span></button>
        <button class="action-btn enhance-hover" id="btnPass">패스<span class="hotkey-hint">[5]</span></button>
      </div>
      <div class="game-hint" id="gameHint">내 턴에만 행동할 수 있습니다</div>
    </div>

    <!-- 초상화/스탯 -->
    <div class="card battle-portrait sparkle-effect">
      <div class="portrait-character" id="portraitChar" style="display:none"></div>
      <div class="portrait-stats" id="portraitStats" style="display:none"></div>
    </div>

    <!-- 전투 로그 -->
    <div class="card sparkle-effect">
      <div class="section-header">
        <div class="section-title" style="font-size:16px;">전투 로그</div>
      </div>
      <div id="battleLog" class="battle-log" aria-label="전투 로그"></div>
    </div>
  </section>
  <!-- 우측: 채팅 -->
  <aside class="card chat-panel sparkle-effect">
    <div class="section-header">
      <div class="section-title" style="font-size:16px;">실시간 채팅</div>
    </div>
    <div class="chat-header">
      <select id="chatChannel" class="select chat-channel enhance-hover">
        <option value="all">전체</option>
        <option value="team">팀</option>
      </select>
      <input id="chatInput" class="input chat-input enhance-hover" placeholder="메시지 입력 (/t 팀 채팅)" maxlength="200">
      <button id="chatSend" class="btn chat-send enhance-hover">전송</button>
    </div>
    <div id="chatMessages" class="chat-messages" aria-label="채팅 메시지"></div>
  </aside>
</main>
<!-- 타겟 선택 -->
<div class="target-overlay" id="targetOverlay" role="dialog" aria-modal="true">
  <div class="target-panel sparkle-effect">
    <div class="target-title" id="targetTitle">대상 선택</div>
    <div class="target-list" id="targetList"></div>
    <div class="target-actions">
      <button class="btn enhance-hover" id="cancelTarget">취소</button>
    </div>
  </div>
</div>
<script>
(function(){
  'use strict';
  const $ = id => document.getElementById(id);

  // DOM 요소
  const connectionStatus = $('connectionStatus');
  const connectionDot = $('connectionDot');
  const connectionText = $('connectionText');

  // 인증 UI
  const authSection = $('authSection');
  const authBattleId = $('authBattleId');
  const authToken = $('authToken');
  const authName = $('authName');
  const authJoinBtn = $('authJoinBtn');

  // 게임 UI
  const allyUnits = $('allyUnits');
  const playerNameEl = $('playerName');
  const playerTeamEl = $('playerTeam');
  const turnStatus = $('turnStatus');
  const gameHint = $('gameHint');

  // 액션 버튼
  const btnAttack = $('btnAttack');
  const btnDefend = $('btnDefend');
  const btnDodge = $('btnDodge');
  const btnUseItem = $('btnUseItem');
  const btnPass = $('btnPass');

  // 초상화/로그/채팅
  const portraitChar = $('portraitChar');
  const portraitStats = $('portraitStats');
  const battleLog = $('battleLog');
  const chatChannel = $('chatChannel');
  const chatInput = $('chatInput');
  const chatSend = $('chatSend');
  const chatMessages = $('chatMessages');

  // 타겟 선택
  const targetOverlay = $('targetOverlay');
  const targetTitle = $('targetTitle');
  const targetList = $('targetList');
  const cancelTarget = $('cancelTarget');

  // 상태 관리
  let socket = null;
  let state = null;
  let myPid = null;
  let me = null;
  let joined = false;
  let currentBattleId = null;
  let reconnectAttempts = 0;
  let reconnectTimer = null;
  const MAX_RECONNECT_ATTEMPTS = 5;
  const RECONNECT_DELAY = 1000;

  // 소켓 초기화
  const initSocket = () => {
    if (socket) {
      socket.disconnect();
    }
    
    socket = io({
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,
      reconnectionDelay: RECONNECT_DELAY,
      reconnectionDelayMax: 10000,
      maxReconnectionAttempts: MAX_RECONNECT_ATTEMPTS,
      timeout: 20000,
      forceNew: true
    });

    setupSocketEvents();
    return socket;
  };

  // 연결 상태 업데이트
  const updateConnectionStatus = (status, text) => {
    connectionDot.className = `connection-dot ${status}`;
    connectionText.textContent = text;
    
    switch(status) {
      case 'connected':
        connectionDot.style.background = 'var(--success)';
        break;
      case 'connecting':
        connectionDot.style.background = 'var(--warning)';
        break;
      case 'disconnected':
      default:
        connectionDot.style.background = 'var(--danger)';
        break;
    }
  };

  // 알림 시스템
  const showNotification = (message, type = 'info') => {
    console.log(`[${type.toUpperCase()}] ${message}`);
    
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed; top: 20px; right: 20px; z-index: 10000;
      padding: 12px 20px; border-radius: 8px; color: white; font-weight: 600;
      background: ${type === 'error' ? 'linear-gradient(135deg, #e74c3c, #c0392b)' : 
                   type === 'success' ? 'linear-gradient(135deg, #27ae60, #219a52)' : 
                   'linear-gradient(135deg, #3498db, #2980b9)'};
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transform: translateX(100%); transition: transform 0.3s ease;
      max-width: 300px; word-wrap: break-word;
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => toast.style.transform = 'translateX(0)', 100);
    setTimeout(() => {
      if (document.body.contains(toast)) {
        toast.style.transform = 'translateX(100%)';
        setTimeout(() => {
          if (document.body.contains(toast)) {
            document.body.removeChild(toast);
          }
        }, 300);
      }
    }, 3000);
  };

  // 유틸리티 함수
  const fmtTime = t => {
    try { 
      return new Date(t).toLocaleTimeString([], {hour12: false}); 
    } catch { 
      return '--:--:--'; 
    }
  };
  
  const teamLabel = key => (key === 'A' || key === 'team1') ? '불사조 기사단' : '죽음을 먹는 자들';
  const hpPct = p => !p ? 0 : Math.max(0, Math.min(100, Math.round((p.hp / (p.maxHp || 100)) * 100)));
  const currActor = () => state?.turn?.pending?.[0] || state?.turn?.actor || null;
  const isMyTurn = () => (currActor() === myPid) && (me?.alive !== false);

  // 로그 및 채팅 함수
  const log = (txt, type = 'info') => {
    const row = document.createElement('div');
    row.className = `log-entry ${type}`;
    
    const t = document.createElement('span');
    t.className = 'time';
    t.textContent = fmtTime(Date.now());
    
    const c = document.createElement('span');
    c.className = 'content';
    c.textContent = txt;
    
    row.appendChild(t);
    row.appendChild(c);
    battleLog.appendChild(row);
    battleLog.scrollTop = battleLog.scrollHeight;

    // 최대 로그 개수 제한
    while (battleLog.children.length > 100) {
      battleLog.removeChild(battleLog.firstChild);
    }
  };
  
  const addChat = (m) => {
    const wrap = document.createElement('div');
    wrap.className = `chat-message ${m.type || (m.scope === 'team' ? 'team' : '')}`;
    
    const t = document.createElement('span');
    t.className = 'chat-time';
    t.textContent = fmtTime(m.ts || Date.now());
    
    const c = document.createElement('span');
    c.className = 'chat-content';
    
    if (m.type === 'system') {
      c.textContent = `[시스템] ${m.text}`;
    } else if (m.type === 'cheer') {
      c.textContent = `[응원] ${m.from?.nickname || m.from || '익명'}: ${m.text}`;
    } else {
      const scope = (m.scope === 'team' || m.channel === 'team') ? '[팀] ' : '[전체] ';
      const nick = m.from?.nickname || m.from || m.nickname || '익명';
      c.textContent = `${scope}${nick}: ${m.text}`;
    }
    
    wrap.appendChild(t);
    wrap.appendChild(c);
    chatMessages.appendChild(wrap);
    chatMessages.scrollTop = chatMessages.scrollHeight;

    // 최대 채팅 개수 제한
    while (chatMessages.children.length > 100) {
      chatMessages.removeChild(chatMessages.firstChild);
    }
  };

  // 소켓 이벤트 설정
  const setupSocketEvents = () => {
    if (!socket) return;

    // 연결 이벤트
    socket.on('connect', () => {
      updateConnectionStatus('connected', '연결됨');
      reconnectAttempts = 0;
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      showNotification('서버에 연결되었습니다', 'success');
      console.log('[Socket] Connected to server');
    });

    socket.on('disconnect', (reason) => {
      updateConnectionStatus('disconnected', '연결 끊김');
      console.log(`[Socket] Disconnected: ${reason}`);
      
      if (joined) {
        if (reason === 'io server disconnect') {
          showNotification('서버와의 연결이 종료되었습니다', 'error');
        } else {
          showNotification('연결이 끊어졌습니다. 재연결 시도 중...', 'error');
        }
      }
    });

    socket.on('connect_error', (error) => {
      updateConnectionStatus('disconnected', '연결 실패');
      console.error('[Socket] Connection error:', error);
      
      if (joined) {
        showNotification(`연결 오류: ${error.message || '알 수 없는 오류'}`, 'error');
      }
    });

    socket.on('reconnect', (attemptNumber) => {
      updateConnectionStatus('connected', '재연결됨');
      showNotification(`서버에 재연결되었습니다 (시도 ${attemptNumber}회)`, 'success');
      console.log(`[Socket] Reconnected after ${attemptNumber} attempts`);
      
      // 재연결 후 상태 복구
      if (joined && currentBattleId) {
        requestStateUpdate();
      }
    });

    socket.on('reconnect_attempt', (attemptNumber) => {
      updateConnectionStatus('connecting', `재연결 중... (${attemptNumber}회)`);
      console.log(`[Socket] Reconnection attempt ${attemptNumber}`);
    });

    socket.on('reconnect_failed', () => {
      updateConnectionStatus('disconnected', '재연결 실패');
      showNotification('서버 재연결에 실패했습니다', 'error');
      console.error('[Socket] Reconnection failed');
    });

    // 게임 이벤트
    socket.on('chat:new', (message) => {
      try {
        addChat(message);
      } catch (error) {
        console.error('[Socket] Error handling chat message:', error);
      }
    });

    socket.on('chat', (message) => {
      try {
        addChat(message);
      } catch (error) {
        console.error('[Socket] Error handling chat:', error);
      }
    });

    socket.on('log:new', (ev) => {
      try {
        if (ev?.text) {
          log(ev.text, 'system');
        }
      } catch (error) {
        console.error('[Socket] Error handling log:', error);
      }
    });
    
    socket.on('phase:change', (p) => {
      try {
        const teamName = (p.phase === 'A' || p.phase === 'team1') ? '불사조 기사단' : '죽음을 먹는 자들';
        log(`▶︎ 턴 전환: ${teamName} (라운드 ${p.round})`, 'system');
        
        if (state) {
          state.turn = { ...state.turn, actor: null, pending: [], phase: p.phase, round: p.round };
          state.phase = p.phase;
          state.round = p.round;
        }
        
        render();
      } catch (error) {
        console.error('[Socket] Error handling phase change:', error);
      }
    });
    
    socket.on('battle:end', (r) => {
      try {
        const winnerText = r.winner === 'draw' ? '무승부' : 
                          (r.winner === 'A' || r.winner === 'team1' ? '불사조 기사단' : '죽음을 먹는 자들');
        log(`◆ 전투 종료: ${winnerText} / A=${r.scoreA || 0} / B=${r.scoreB || 0}`, 'system');
        showNotification('전투가 종료되었습니다', 'info');
      } catch (error) {
        console.error('[Socket] Error handling battle end:', error);
      }
    });

    socket.on('state:update', (s) => {
      try {
        state = s;
        me = myPid && s?.players ? s.players[myPid] : me;
        render();
      } catch (error) {
        console.error('[Socket] Error handling state update:', error);
      }
    });
    
    socket.on('state', (s) => {
      try {
        state = s;
        me = myPid && s?.players ? s.players[myPid] : me;
        render();
      } catch (error) {
        console.error('[Socket] Error handling state:', error);
      }
    });

    // 인증 응답
    socket.on('authSuccess', (response) => {
      try {
        joined = true;
        state = response.state || response.battle;
        myPid = response.selfPid || response.playerId;
        me = myPid && state?.players ? state.players[myPid] : null;
        
        authSection.style.display = 'none';
        render();
        
        authJoinBtn.classList.add('feedback-success');
        log('전투에 성공적으로 참가했습니다!', 'system');
        showNotification('전투 입장 완료!', 'success');
        
        setTimeout(() => {
          authJoinBtn.textContent = '전투 참가';
          authJoinBtn.classList.remove('feedback-success');
        }, 2000);
      } catch (error) {
        console.error('[Socket] Error handling auth success:', error);
        showNotification('인증 처리 중 오류가 발생했습니다', 'error');
      }
    });

    socket.on('authError', (message) => {
      authJoinBtn.classList.add('feedback-error');
      setTimeout(() => {
        authJoinBtn.textContent = '전투 참가';
        authJoinBtn.classList.remove('feedback-error');
      }, 2000);
      
      showNotification(`인증 실패: ${message || '알 수 없는 오류'}`, 'error');
    });

    // 액션 응답
    socket.on('actionSuccess', (result) => {
      if (result?.message) {
        showNotification(result.message, 'success');
      }
    });

    socket.on('actionError', (message) => {
      showNotification(`행동 실패: ${message || '알 수 없는 오류'}`, 'error');
    });

    // 채팅 오류
    socket.on('chatError', (error) => {
      showNotification(`채팅 오류: ${error}`, 'error');
    });

    // 오류 처리
    socket.on('error', (error) => {
      console.error('[Socket] Generic error:', error);
      showNotification('소켓 오류가 발생했습니다', 'error');
    });
  };

  // 상태 업데이트 요청
  const requestStateUpdate = () => {
    if (socket && socket.connected && currentBattleId) {
      socket.emit('requestState', { battleId: currentBattleId });
    }
  };

  // 인증 함수 (다중 시도)
  const doJoin = (battleId, token, name) => {
    if (!socket || !socket.connected) {
      showNotification('서버에 연결되어 있지 않습니다', 'error');
      return;
    }

    currentBattleId = battleId;
    authJoinBtn.classList.add('loading');
    authJoinBtn.textContent = '접속 중...';
    
    // 타임아웃 설정
    const authTimeout = setTimeout(() => {
      authJoinBtn.classList.remove('loading');
      authJoinBtn.textContent = '전투 참가';
      authJoinBtn.classList.add('feedback-error');
      setTimeout(() => authJoinBtn.classList.remove('feedback-error'), 1000);
      showNotification('인증 요청 시간이 초과되었습니다', 'error');
    }, 10000);

    // 성공/실패 콜백
    const handleAuthResult = (success, message) => {
      clearTimeout(authTimeout);
      authJoinBtn.classList.remove('loading');
      
      if (!success) {
        authJoinBtn.classList.add('feedback-error');
        setTimeout(() => {
          authJoinBtn.textContent = '전투 참가';
          authJoinBtn.classList.remove('feedback-error');
        }, 2000);
        showNotification(message || '인증에 실패했습니다', 'error');
      }
    };

    // 1) 최신 스펙: join 이벤트
    socket.timeout(8000).emit('join', {
      role: 'player',
      battleId,
      token,
      name
    }, (error, ack) => {
      if (error) {
        console.log('[Auth] Join timeout, trying alternative methods');
        // 2) 중간 스펙: playerAuth 이벤트
        socket.timeout(8000).emit('playerAuth', {
          battleId,
          playerId: name,
          otp: token
        }, (error2, ack2) => {
          if (error2) {
            console.log('[Auth] PlayerAuth timeout, trying legacy');
            // 3) 레거시 스펙: auth 이벤트 (응답 없이 이벤트 대기)
            socket.emit('auth', {
              role: 'player',
              battle: battleId,
              token,
              name
            });
          } else if (ack2 && !ack2.ok) {
            handleAuthResult(false, ack2.message || ack2.error);
          }
        });
      } else if (ack && !ack.ok) {
        handleAuthResult(false, ack.msg || ack.message);
      }
    });
  };

  // 전투원 카드 렌더링
  const unitCard = (p) => {
    const el = document.createElement('div');
    el.className = `unit enhance-hover ${currActor() === p.id ? 'active' : ''} ${p.alive === false ? 'dead' : ''}`;
    el.dataset.playerId = p.id;

    const av = document.createElement('div');
    av.className = 'unit-avatar';
    if (p.avatar) av.style.backgroundImage = `url(${p.avatar})`;

    const info = document.createElement('div');
    info.className = 'unit-info';

    const name = document.createElement('div');
    name.className = `unit-name ${p.alive === false ? 'dead' : ''}`;
    name.textContent = p.name;

    const hp = document.createElement('div');
    hp.className = 'unit-hp';
    const bar = document.createElement('span');
    bar.className = 'unit-hp-bar';
    bar.style.width = `${hpPct(p)}%`;
    hp.appendChild(bar);

    const st = document.createElement('div');
    st.className = 'unit-stats';
    const s = p.stats || { attack: p.atk, defense: p.def, agility: p.agi, luck: p.luk };
    st.textContent = `공격 ${s.attack ?? p.atk} · 방어 ${s.defense ?? p.def} · 민첩 ${s.agility ?? p.agi} · 행운 ${s.luck ?? p.luk}`;

    info.appendChild(name);
    info.appendChild(hp);
    info.appendChild(st);
    el.appendChild(av);
    el.appendChild(info);
    return el;
  };

  // 렌더링 함수들
  const renderTeam = () => {
    if (!state?.players || !me) return;
    allyUnits.innerHTML = '';
    const allies = Object.values(state.players).filter(x => {
      const tA = (x.team === 'A' || x.team === 'team1');
      const myT = (me.team === 'A' || me.team === 'team1');
      return tA === myT;
    });

    allies.forEach(p => allyUnits.appendChild(unitCard(p)));
  };

  const renderInfo = () => {
    if (!me) return;
    playerNameEl.textContent = me.name || '-';
    playerTeamEl.textContent = teamLabel(me.team);

    const mine = isMyTurn();
    turnStatus.textContent = mine ? '내 차례!' : '대기중';
    turnStatus.classList.toggle('active', mine);

    // 행동 버튼 활성화/비활성화
    [btnAttack, btnDefend, btnDodge, btnUseItem, btnPass].forEach(b => {
      b.disabled = !mine;
    });

    if (mine) {
      gameHint.textContent = '행동을 선택하세요!';
      gameHint.classList.add('active');
    } else {
      gameHint.textContent = '내 턴을 기다리는 중...';
      gameHint.classList.remove('active');
    }
  };

  const renderPortrait = () => {
    const aId = currActor();
    const p = aId && state?.players?.[aId];
    if (p) {
      portraitChar.style.display = 'block';
      portraitChar.style.backgroundImage = p.avatar ? `url(${p.avatar})` : '';
      portraitChar.classList.remove('left', 'right');
      
      const isEnemy = (p.team === 'B' || p.team === 'team2');
      portraitChar.classList.add(isEnemy ? 'right' : 'left');
      portraitChar.classList.toggle('active', aId === myPid);

      const s = p.stats || { attack: p.atk, defense: p.def, agility: p.agi, luck: p.luk };
      portraitStats.style.display = 'flex';
      portraitStats.innerHTML = `
        <div class="stat-item"><span class="stat-label">이름:</span><span class="stat-value">${p.name}</span></div>
        <div class="stat-item"><span class="stat-label">팀:</span><span class="stat-value">${teamLabel(p.team)}</span></div>
        <div class="stat-item"><span class="stat-label">HP:</span><span class="stat-value">${p.hp}/${p.maxHp || 100}</span></div>
        <div class="stat-item"><span class="stat-label">공격:</span><span class="stat-value">${s.attack ?? p.atk}</span></div>
        <div class="stat-item"><span class="stat-label">방어:</span><span class="stat-value">${s.defense ?? p.def}</span></div>
        <div class="stat-item"><span class="stat-label">민첩:</span><span class="stat-value">${s.agility ?? p.agi}</span></div>
        <div class="stat-item"><span class="stat-label">행운:</span><span class="stat-value">${s.luck ?? p.luk}</span></div>
      `;
    } else {
      portraitChar.style.display = 'none';
      portraitStats.style.display = 'none';
    }
  };

  const renderBattleLog = () => {
    if (!state?.chat) return;
    battleLog.innerHTML = '';
    state.chat.slice(-50).forEach(e => {
      if (e.type === 'system' || e.type === 'action') {
        log(e.text, e.type);
      }
    });
  };

  const render = () => {
    try {
      if (!state) return;
      me = myPid && state.players ? state.players[myPid] : me;
      renderInfo();
      renderPortrait();
      renderTeam();
      renderBattleLog();
    } catch (error) {
      console.error('[Render] Error during render:', error);
    }
  };

  // 타겟 선택 UI
  const showTargets = (title, targets, cb) => {
    targetTitle.textContent = title;
    targetList.innerHTML = '';
    targets.forEach(t => {
      const card = document.createElement('div');
      card.className = `target-card enhance-hover ${t.alive === false ? 'disabled' : ''}`;
      
      const n = document.createElement('div');
      n.className = 'target-name';
      n.textContent = t.name;
      
      const h = document.createElement('div');
      h.className = 'target-hp';
      h.textContent = `HP ${t.hp}/${t.maxHp || 100}`;
      
      card.appendChild(n);
      card.appendChild(h);
      
      if (t.alive !== false) {
        card.onclick = () => {
          hideTargets();
          cb(t);
        };
      }
      
      targetList.appendChild(card);
    });

    targetOverlay.style.display = 'flex';
  };

  const hideTargets = () => {
    targetOverlay.style.display = 'none';
  };

  // 액션 전송 (다중 폴백)
  const sendAction = (type, payload = {}) => {
    if (!socket || !socket.connected) {
      showNotification('서버에 연결되어 있지 않습니다', 'error');
      return;
    }
    const msg = { type, ...payload };
    console.log('[Action] Sending:', msg);

    // 1) 최신 스펙: action:player
    socket.timeout(5000).emit('action:player', msg, (error, ack) => {
      if (error || (ack && ack.ok === false)) {
        console.log('[Action] Primary method failed, trying alternative');
        
        // 2) 중간 스펙: player:action
        socket.timeout(5000).emit('player:action', msg, (error2, ack2) => {
          if (error2 || (ack2 && ack2.ok === false)) {
            console.log('[Action] Secondary method failed, trying legacy');
            
            // 3) 레거시 스펙: playerAction
            socket.emit('playerAction', {
              battleId: currentBattleId,
              playerId: myPid,
              action: msg
            });
          }
        });
      }
    });
  };

  // 액션 구현
  const getEnemies = () => {
    if (!state?.players || !me) return [];
    return Object.values(state.players).filter(p => {
      const myT = (me.team === 'A' || me.team === 'team1');
      const t = (p.team === 'A' || p.team === 'team1');
      return t !== myT && p.alive !== false;
    });
  };

  const getAllies = () => {
    if (!state?.players || !me) return [];
    return Object.values(state.players).filter(p => {
      const myT = (me.team === 'A' || me.team === 'team1');
      const t = (p.team === 'A' || p.team === 'team1');
      return t === myT && p.alive !== false;
    });
  };

  const doAttack = () => {
    const targets = getEnemies();
    if (targets.length === 0) {
      showNotification('공격할 대상이 없습니다!', 'error');
      return;
    }
    showTargets('공격 대상 선택', targets, (t) => {
      sendAction('attack', { targetPid: t.id });
    });
  };

  const doDefend = () => sendAction('defend');
  const doEvade = () => sendAction('evade');

  const doUseItem = () => {
    const itemsList = ['디터니', '공격 보정기', '방어 보정기'];
    const pick = prompt(`사용할 아이템을 입력하세요:\n${itemsList.join(', ')}`);
    if (!pick) return;
    if (pick === '디터니') {
      const targets = getAllies();
      if (targets.length === 0) {
        showNotification('회복 대상이 없습니다!', 'error');
        return;
      }
      showTargets('회복 대상 선택', targets, (t) => {
        sendAction('useItem', { item: '디터니', targetPid: t.id });
      });
    } else if (pick === '공격 보정기' || pick === '방어 보정기') {
      sendAction('useItem', { item: pick, targetPid: myPid });
    } else {
      showNotification('알 수 없는 아이템입니다.', 'error');
    }
  };

  const doPass = () => {
    if (confirm('정말로 턴을 넘기시겠습니까?')) {
      sendAction('pass');
    }
  };

  // 채팅 전송
  const sendChat = () => {
    const txt = chatInput.value.trim();
    if (!txt) return;
    if (!socket || !socket.connected) {
      showNotification('서버에 연결되어 있지 않습니다', 'error');
      return;
    }

    // /t 접두사 처리
    let scope = (chatChannel.value === 'team') ? 'team' : 'all';
    let text = txt;
    if (txt.startsWith('/t ')) {
      scope = 'team';
      text = txt.slice(3).trim();
      if (!text) return;
    }

    const nickname = me?.name || '플레이어';

    // 1) 신규 스펙
    socket.emit('chat:send', {
      battleId: currentBattleId,
      text,
      nickname,
      role: 'player',
      scope
    }, (ack) => {
      if (ack && ack.ok === false) {
        showNotification(`채팅 오류: ${ack.msg || '전송 실패'}`, 'error');
      }
    });

    // 2) 레거시 폴백
    socket.emit('chatMessage', {
      message: text,
      channel: scope === 'team' ? 'team' : 'all'
    });

    chatInput.value = '';
  };

  // 이벤트 바인딩
  const setupEventListeners = () => {
    // 액션 버튼
    btnAttack.onclick = doAttack;
    btnDefend.onclick = doDefend;
    btnDodge.onclick = doEvade;
    btnUseItem.onclick = doUseItem;
    btnPass.onclick = doPass;

    // 채팅
    chatSend.onclick = sendChat;
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendChat();
    });

    // 타겟 선택
    cancelTarget.onclick = hideTargets;

    // 단축키
    document.addEventListener('keydown', (e) => {
      if (targetOverlay.style.display === 'flex') return; // 타겟 선택 중엔 차단
      if (!isMyTurn()) return;
      
      switch (e.key) {
        case '1':
          e.preventDefault();
          doAttack();
          break;
        case '2':
          e.preventDefault();
          doDefend();
          break;
        case '3':
          e.preventDefault();
          doEvade();
          break;
        case '4':
          e.preventDefault();
          doUseItem();
          break;
        case '5':
          e.preventDefault();
          doPass();
          break;
      }
    });

    // 인증 관련
    authJoinBtn.onclick = () => {
      const b = authBattleId.value.trim();
      const t = authToken.value.trim();
      const n = authName.value.trim();
      
      if (!b || !t || !n) {
        authJoinBtn.classList.add('feedback-error');
        setTimeout(() => authJoinBtn.classList.remove('feedback-error'), 1000);
        return showNotification('모든 필드를 입력해주세요!', 'error');
      }
      
      doJoin(b, t, n);
    };

    // 엔터키로 인증
    [authBattleId, authToken, authName].forEach(input => {
      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') authJoinBtn.click();
      });
    });

    // 윈도우 이벤트
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (joined && state) render();
      }, 250);
    });

    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && joined && state) {
        render();
        requestStateUpdate();
      }
    });

    // ESC 키로 타겟 선택 닫기
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && targetOverlay.style.display === 'flex') {
        hideTargets();
      }
    });
  };

  // URL 파라미터 자동 인증
  const initFromUrl = () => {
    const urlParams = new URLSearchParams(location.search);
    const b = urlParams.get('battle');
    const t = urlParams.get('token');
    const n = urlParams.get('name');
    if (b && t && n) {
      authBattleId.value = b;
      authToken.value = t;
      authName.value = decodeURIComponent(n);
      
      // 소켓 연결 후 자동 인증
      if (socket && socket.connected) {
        setTimeout(() => doJoin(b, t, n), 500);
      } else {
        socket.on('connect', () => {
          setTimeout(() => doJoin(b, t, n), 500);
        });
      }
    } else {
      authSection.style.display = 'block';
    }
  };

  // 초기화
  const initialize = () => {
    updateConnectionStatus('connecting', '연결 중...');
    try {
      initSocket();
      setupEventListeners();
      initFromUrl();
      
      console.log('[Init] Player client initialized');
      
      // 로컬 디버그
      if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
        window.playerDebug = {
          state: () => state,
          socket: () => socket,
          render,
          me: () => me,
          reconnect: initSocket,
          requestState: requestStateUpdate
        };
        console.log('플레이어 디버그 모드: window.playerDebug 사용 가능');
      }
    } catch (error) {
      console.error('[Init] Initialization error:', error);
      showNotification('초기화 중 오류가 발생했습니다', 'error');
    }
  };

  // 페이지 로드 완료 후 초기화
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initialize);
  } else {
    initialize();
  }

  // 정리 함수
  const cleanup = () => {
    if (socket) {
      socket.disconnect();
      socket = null;
    }
    if (reconnectTimer) {
      clearTimeout(reconnectTimer);
      reconnectTimer = null;
    }
    state = null;
    me = null;
    joined = false;
    currentBattleId = null;
  };

  // 페이지 언로드 시 정리
  window.addEventListener('beforeunload', cleanup);
  window.addEventListener('pagehide', cleanup);

  // 전역 오류 처리
  window.addEventListener('error', (event) => {
    console.error('[Global Error]', event.error);
  });
  window.addEventListener('unhandledrejection', (event) => {
    console.error('[Unhandled Promise Rejection]', event.reason);
  });
})();
</script>
</body>
</html>
