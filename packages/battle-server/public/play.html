<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>PYXIS - 플레이어</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="/socket.io/socket.io.js"></script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500;600;700&family=Inter:wght@400;600&display=swap" rel="stylesheet" />

  <style>
    :root{
      /* PYXIS Gold Theme */
      --deep-navy: #0a0f1a;
      --midnight: #121827;
      --navy-mist: #1a202c;

      --glass-dark: rgba(201,169,110,0.03);
      --glass:      rgba(201,169,110,0.06);
      --glass-br:   rgba(201,169,110,0.12);

      --pyxis-gold:        #c9a96e;
      --pyxis-gold-dark:   #b8975f;
      --pyxis-gold-light:  #d8bd86;
      --pyxis-gold-bright: #e6cf9e;
      --pyxis-shimmer:     #f2e5c7;

      --text:         #f8f4ec;
      --text-2:       #d4c7b0;
      --text-muted:   #9a8d7a;

      --line: rgba(201,169,110,0.18);
      --line-strong: rgba(201,169,110,0.28);

      --radius: 16px;

      --serif: 'Playfair Display', serif;
      --sans:  'Inter', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    *{ box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin: 0;
      color: var(--text);
      font-family: var(--sans);
      background: radial-gradient(1200px 1200px at 20% 0%, rgba(201,169,110,0.08), transparent 60%),
                  radial-gradient(800px 800px at 80% 100%, rgba(201,169,110,0.06), transparent 60%),
                  linear-gradient(135deg, var(--deep-navy) 0%, var(--midnight) 45%, var(--navy-mist) 100%);
      overflow-x: hidden;
    }

    .container{
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Header */
    .brand{
      font-family: var(--serif);
      font-weight: 700;
      font-size: clamp(28px, 4vw, 40px);
      text-align: center;
      letter-spacing: .04em;
      margin: 6px 0 18px;
      background: linear-gradient(135deg, var(--pyxis-gold), var(--pyxis-shimmer), var(--pyxis-gold-bright));
      -webkit-background-clip: text; background-clip: text;
      -webkit-text-fill-color: transparent;
      position: relative;
      display: inline-block;
      width: 100%;
    }
    .brand::before, .brand::after{
      content: '✦';
      position: absolute;
      top: .05em;
      font-size: .45em;
      color: var(--pyxis-gold-light);
      animation: twinkle 2.6s ease-in-out infinite alternate;
    }
    .brand::before{ left: 12%; animation-delay: 0s; }
    .brand::after { right: 12%; animation-delay: 1.2s; }

    @keyframes twinkle{
      0%, 100% { opacity: .45; transform: scale(.85); }
      50% { opacity: 1; transform: scale(1.15); }
    }

    /* Cards */
    .card{
      background: linear-gradient(145deg, var(--glass-dark), var(--glass));
      backdrop-filter: blur(14px);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: 0 8px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
      padding: 16px;
      margin-bottom: 18px;
      transition: box-shadow .25s ease, border-color .25s ease, transform .2s ease;
    }
    .card:hover{
      border-color: var(--line-strong);
      box-shadow: 0 12px 36px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.04);
      transform: translateY(-2px);
    }
    .card h2, .card h3{
      font-family: var(--serif);
      color: var(--pyxis-gold-bright);
      margin: 0 0 10px;
      letter-spacing: .02em;
      font-weight: 600;
    }

    /* Grids */
    .grid-2{ display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .grid-3{ display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
    .board { display: grid; grid-template-columns: 1fr 1.4fr 1fr; gap: 16px; }

    /* Auth */
    label{ display:block; font-size: 13px; color: var(--text-2); margin: 6px 0 6px; }
    input, button, select{
      width: 100%;
      padding: 12px 12px;
      font-size: 15px;
      border-radius: 12px;
      outline: none;
      transition: border .2s ease, background .2s ease, box-shadow .2s ease, transform .08s ease;
    }
    input, select{
      background: rgba(16,21,35,.75);
      border: 1px solid var(--line);
      color: var(--text);
    }
    input:focus, select:focus{
      border-color: var(--pyxis-gold);
      box-shadow: 0 0 0 2px rgba(201,169,110,.18);
    }
    .btn{
      border: 1px solid var(--pyxis-gold-dark);
      background: linear-gradient(135deg, var(--pyxis-gold-dark), var(--pyxis-gold));
      color: #091018;
      font-weight: 700;
      cursor: pointer;
    }
    .btn:hover{ filter: brightness(1.06); }
    .btn:active{ transform: translateY(1px); }
    .btn-ghost{
      background: rgba(16,21,35,.65);
      border: 1px solid var(--line);
      color: var(--text);
      font-weight: 600;
    }
    .btn-ghost:hover{ border-color: var(--line-strong); }

    .muted{ color: var(--text-muted); font-size: 13px; }
    .hidden{ display:none !important; }

    /* Status header */
    .status-bar{
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap: wrap;
    }
    .status-pill{
      display:inline-block; padding: 6px 10px; border-radius: 999px;
      border: 1px solid var(--line); background: rgba(201,169,110,.08);
      color: var(--pyxis-gold-bright); font-weight: 600; font-size: 13px;
    }

    /* Teams */
    .team-col{
      background: rgba(16,21,35,.55);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
    }
    .team-col h4{
      margin: 0 0 8px;
      color: var(--pyxis-gold-light);
      font-family: var(--serif);
      letter-spacing: .02em;
      font-weight: 600;
    }

    /* Player card */
    .pcard{
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      background: rgba(12,16,26,.55);
      margin-bottom: 10px;
      position: relative; overflow: hidden;
    }
    .pcard:hover::before{
      opacity: 1;
    }
    .pc-grid{
      display:grid; grid-template-columns: auto 1fr auto; gap:12px; align-items:center;
    }
    .ring{
      width: 56px; height: 56px; border-radius: 50%;
      background: conic-gradient(var(--pyxis-gold) calc(var(--hp,100)*1%), #263041 0);
      display: grid; place-items: center;
      border: 2px solid var(--line);
      position: relative; overflow: hidden;
    }
    .ring:after{
      content:'';
      position:absolute; inset:2px; border-radius:50%;
      background: conic-gradient(transparent calc(var(--hp,100)*1%), rgba(201,169,110,.12) 0);
      animation: ringpulse 2s ease-in-out infinite alternate;
    }
    @keyframes ringpulse{
      0% { box-shadow: inset 0 0 10px rgba(201,169,110,.22); }
      100%{ box-shadow: inset 0 0 18px rgba(201,169,110,.36); }
    }
    .avatar{
      width: 44px; height: 44px; border-radius: 50%;
      border: 1px solid var(--line);
      background: var(--avatar, linear-gradient(135deg, #0f1724, #1b2232)) center/cover no-repeat;
      z-index: 1;
    }
    .pname{ font-weight: 700; color: var(--text); }
    .psub { font-size:12px; color: var(--text-muted); }

    .hpbar{
      position: relative; height: 8px; border-radius: 6px;
      border: 1px solid var(--line);
      background: #151c28; overflow: hidden;
      margin-top: 6px;
    }
    .hpbar .fill{
      position:absolute; inset:0; width: var(--w,100%);
      background: linear-gradient(90deg, var(--pyxis-gold-dark), var(--pyxis-gold));
      transition: width .25s ease;
    }

    .action-row{
      display: grid; grid-template-columns: repeat(2,1fr); gap:8px; margin-top: 10px;
    }
    .action-row .btn{ font-size:.92em; padding: 10px 10px; border-radius: 10px; }
    .btn-pass{ background: linear-gradient(135deg, #6b6b6b, #8a8a8a); border:1px solid #797979; color:#0a0f1a; grid-column: 1 / -1; }
    .btn-pass:hover{ background: linear-gradient(135deg, #7b7b7b, #9b9b9b); }

    .ready-row{ display:flex; gap:8px; margin-top:8px; }
    .ready-btn{ flex:1; border:1px solid var(--line); background: rgba(16,21,35,.65); color:var(--text); font-weight:600; }
    .ready-btn.on{ background: linear-gradient(135deg, #4a6741, #5a7951); border-color:#6b8f6b; color:#cfe8c1; }

    .badge-dead{ display:inline-block; padding:2px 6px; border:1px solid var(--line); border-radius:8px; font-size:11px; color:var(--text-muted); margin-left:6px; }

    /* Log & Chat */
    .log-box, .chat-box{
      background: rgba(12,16,26,.55);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      box-shadow: inset 0 2px 4px rgba(0,0,0,.25);
    }
    .log-scroll, .chat-scroll{ height: 300px; overflow-y:auto; font-size:13px; line-height:1.45; }
    .logline{ padding: 4px 6px; border-radius: 6px; margin: 2px 0; }
    .logline:hover{ background: rgba(201,169,110,.06); }
    .logline .t{ color: var(--text-muted); margin-right: 6px; font-weight: 600; }
    .tag{
      display:inline-block; padding: 2px 6px; border-radius: 999px;
      border: 1px solid var(--line); color: var(--text-2);
      font-size: 10px; font-weight: 600; margin-right: 6px; vertical-align: 1px;
    }
    .tag-admin{ background: var(--pyxis-shimmer); color:#0a0f1a; border-color: var(--pyxis-shimmer); }
    .tag-team { background: var(--pyxis-gold); color:#0a0f1a; border-color: var(--pyxis-gold); }

    .chat-input{ display:flex; gap:8px; margin-top: 10px; }
    .chat-input input{ flex: 1; }

    .filters{ display:flex; gap:8px; flex-wrap: wrap; align-items:center; }

    /* Pinned Notice */
    .notice{
      background: linear-gradient(145deg, rgba(201,169,110,0.08), rgba(201,169,110,0.12));
      border: 1px solid var(--pyxis-gold);
      border-radius: var(--radius);
      padding: 12px;
      backdrop-filter: blur(8px);
      box-shadow: 0 4px 16px rgba(201,169,110,0.1);
      margin-bottom: 10px;
    }
    .notice .title{ font-family: var(--serif); color: var(--pyxis-gold-bright); font-weight: 600; margin-bottom: 6px; }
    .notice .body{ white-space: pre-wrap; }

    /* Target modal */
    .modal{ position: fixed; inset:0; background: rgba(0,0,0,.5); display:none; align-items:center; justify-content:center; z-index: 50; }
    .modal.show{ display:flex; }
    .modal .panel{ width: min(520px, 92vw); background: linear-gradient(145deg, var(--glass-dark), var(--glass)); border:1px solid var(--line); border-radius: 14px; padding: 14px; }
    .targets{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 8px; }
    .target-btn{
      border:1px solid var(--line); background: rgba(16,21,35,.65); color:var(--text); border-radius: 10px; padding: 10px;
      display:flex; gap:10px; align-items:center; cursor: pointer;
    }
    .target-btn:hover{ border-color: var(--line-strong); }

    /* Responsive */
    @media (max-width: 1024px){ .board{ grid-template-columns: 1fr 1fr; } }
    @media (max-width: 760px){ .board{ grid-template-columns: 1fr; } .log-scroll, .chat-scroll{ height: 260px; } }
  </style>
</head>
<body>
  <div class="container">
    <div class="brand">PYXIS 플레이어</div>

    <!-- Auth -->
    <section id="auth" class="card">
      <h2>전투 입장</h2>
      <div class="grid-3">
        <div>
          <label for="playerName">플레이어 이름</label>
          <input id="playerName" type="text" placeholder="이름" />
        </div>
        <div>
          <label for="battleId">전투 ID</label>
          <input id="battleId" type="text" placeholder="전투 ID" />
        </div>
        <div>
          <label for="otp">플레이어 OTP</label>
          <input id="otp" type="text" placeholder="OTP" />
        </div>
      </div>
      <div class="grid-3" style="margin-top:10px;">
        <div>
          <label for="teamSel">팀 선택</label>
          <select id="teamSel">
            <option value="team1">team1</option>
            <option value="team2">team2</option>
          </select>
        </div>
        <div>
          <label for="avatarUrl">캐릭터 이미지 URL (선택)</label>
          <input id="avatarUrl" type="url" placeholder="https://..." />
        </div>
        <div style="display:flex; align-items:flex-end;">
          <button id="btnJoin" class="btn">입장</button>
        </div>
      </div>
      <p class="muted" style="margin-top:6px;">URL 쿼리(battle, token, name, team, avatar, pid)로 자동 인식됩니다. 스탯과 아이템은 관리자 페이지에서 설정됩니다.</p>
    </section>

    <!-- Main -->
    <section id="main" class="hidden">
      <div class="card">
        <div class="status-bar">
          <div id="statusPill" class="status-pill">-</div>
          <div class="filters">
            <button id="btnCopyLink" class="btn-ghost">현재 화면 링크 복사</button>
            <label class="muted"><input type="checkbox" id="viewTeamOnly" style="vertical-align:-2px; margin-right:6px;">팀 채팅만 보기</label>
          </div>
        </div>
      </div>

      <div id="noticeBox" class="notice hidden">
        <div class="title" id="noticeTitle"></div>
        <div class="body" id="noticeBody"></div>
      </div>

      <div class="board">
        <!-- Left: My Team -->
        <div class="card">
          <h3 id="team1Title">팀 1</h3>
          <div id="team1List"></div>
        </div>

        <!-- Center: Battle Log + Chat -->
        <div class="card">
          <h3>전투 로그</h3>
          <div id="log" class="log-box">
            <div id="logScroll" class="log-scroll"></div>
          </div>

          <div style="height:10px;"></div>

          <h3>실시간 채팅</h3>
          <div id="chat" class="chat-box">
            <div id="chatScroll" class="chat-scroll"></div>
            <div class="chat-input">
              <input id="chatInput" type="text" placeholder="/t 로 팀 채팅, 미입력 시 전체 채팅" />
              <button id="btnSendChat" class="btn">보내기</button>
            </div>
          </div>
        </div>

        <!-- Right: Enemy Team -->
        <div class="card">
          <h3 id="team2Title">팀 2</h3>
          <div id="team2List"></div>
        </div>
      </div>
    </section>
  </div>

  <!-- Target Modal -->
  <div id="targetModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="targetTitle">
    <div class="panel">
      <h3 id="targetTitle">대상 선택</h3>
      <div class="targets" id="targetList"></div>
      <div style="margin-top:10px; display:flex; gap:8px; justify-content:flex-end;">
        <button id="btnTargetCancel" class="btn-ghost" style="width:auto;">취소</button>
      </div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  // ===== Helpers =====
  const $  = (s) => document.querySelector(s);
  const $$ = (s) => document.querySelectorAll(s);
  const esc = (s='') => String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  const fmtTime = (t) => new Date(t).toLocaleTimeString();
  const qs = () => {
    const p = new URLSearchParams(location.search);
    return {
      battle: p.get('battle') || p.get('b'),
      token:  p.get('token')  || p.get('otp') || p.get('t'),
      name:   p.get('name')   || p.get('n'),
      team:   p.get('team'),
      avatar: p.get('avatar'),
      pid:    p.get('pid')
    };
  };

  // ===== State =====
  let socket = null;
  let battleId = null;
  let playerOtp = null;
  let myId = null;
  let myTeam = null;

  let currentBattle = null;
  let actionLock = false;

  // for target modal
  let pendingAction = null; // { type, scope: 'enemy'|'ally', itemType? }

  // ===== API =====
  async function getBattle(id){
    const r = await fetch(`/api/battles/${encodeURIComponent(id)}`);
    if(!r.ok) throw new Error(`HTTP ${r.status}`);
    return r.json();
  }

  async function joinBattle(){
    const name = $('#playerName').value.trim();
    const team = $('#teamSel').value;
    const avatarUrl = $('#avatarUrl').value.trim();

    if(!battleId || !playerOtp) return alert('전투 ID와 OTP를 입력하세요.');
    if(!name) return alert('이름을 입력하세요.');

    // 이미 pid가 있는 경우(서버가 선등록) join 생략
    if(myId) return connectSocket();

    try{
      const res = await fetch(`/api/battles/${encodeURIComponent(battleId)}/players`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, team, imageUrl: avatarUrl || undefined })
      });
      const data = await res.json();
      if(!res.ok || !data?.player?.id) throw new Error(data?.error || '참가 실패');
      myId = data.player.id;
      myTeam = data.player.team;
      connectSocket();
    }catch(e){
      alert(e.message || '참가 실패');
    }
  }

  // ===== Socket =====
  function connectSocket(){
    if(socket){ try{ socket.disconnect(); }catch(_){ } }

    socket = io({ path: '/socket.io/', transports: ['websocket', 'polling'] });

    socket.on('connect', () => {
      socket.emit('playerAuth', { battleId, otp: playerOtp, playerId: myId });
    });

    socket.on('authSuccess', (data) => {
      if(data?.player?.id) { myId = data.player.id; myTeam = data.player.team; }
      if(data?.battle) { currentBattle = data.battle; hydrateUI(data.battle); }
      $('#auth').classList.add('hidden');
      $('#main').classList.remove('hidden');
    });

    socket.on('authError', (msg) => alert(msg || '인증 실패'));

    socket.on('battleUpdate', (battle) => {
      currentBattle = battle;
      hydrateUI(battle);
    });

    socket.on('actionSuccess', () => { actionLock = false; });
    socket.on('actionError', (msg) => { actionLock = false; alert(msg || '행동 실패'); });

    socket.on('chatMessage', ({ message }) => {
      if(!message) return;
      // 관전자와 달리, 플레이어는 팀 채팅도 수신 가능
      appendChat([message]);
    });

    socket.on('connect_error', (err) => console.warn('소켓 오류:', err?.message || err));
  }

  // ===== Render =====
  function hydrateUI(b){
    if(!b) return;
    renderStatus(b);
    renderNotice(b);
    renderTeams(b);
    renderLog(b);
    renderChat(b);
  }

  function renderStatus(b){
    const turnLeft = b.turnDeadline ? Math.max(0, Math.floor((new Date(b.turnDeadline).getTime() - Date.now())/1000)) : null;
    const tStr = turnLeft != null ? ` | 남은 시간: ${Math.floor(turnLeft/60)}:${String(turnLeft%60).padStart(2,'0')}` : '';
    $('#statusPill').textContent =
      `상태: ${b.status || '-'} | 라운드: ${b.roundNumber ?? '-'} | 턴: ${b.turnNumber ?? '-'} | 현재 팀: ${b.currentTeam ?? '-'}${tStr}`;
  }

  function renderNotice(b){
    const n = b.notice || b.pinnedNotice;
    const box = $('#noticeBox');
    if(n && (n.title || n.body)){
      $('#noticeTitle').textContent = n.title || '공지';
      $('#noticeBody').textContent  = n.body  || '';
      box.classList.remove('hidden');
    } else {
      box.classList.add('hidden');
    }
  }

  function renderTeams(b){
    $('#team1Title').textContent = b.teams?.team1?.name || '팀 1';
    $('#team2Title').textContent = b.teams?.team2?.name || '팀 2';

    const renderList = (teamKey, rootSel) => {
      const root = $(rootSel);
      const team = b.teams?.[teamKey] || { players: [] };
      root.innerHTML = (team.players || []).map(p => {
        const hpPct = Math.max(0, Math.min(100, Math.round((p.hp ?? 0) * 100 / (p.maxHp || 100))));
        const dead  = p.alive === false;
        const avatarStyle = p.imageUrl ? `style="--avatar: url('${esc(p.imageUrl)}');"` : '';
        const isMe  = p.id === myId;

        const statsLine = `ATK ${p.stats?.attack ?? '-'} · DEF ${p.stats?.defense ?? '-'} · AGI ${p.stats?.agility ?? '-'} · LUK ${p.stats?.luck ?? '-'}`;

        let actionArea = '';
        if(isMe){
          const canMyTeamAct = (b.currentTeam === myTeam);
          const canActNow = canMyTeamAct && p.alive && !p.hasActed && b.status === 'ongoing';
          const dis = canActNow ? '' : 'disabled';

          actionArea = `
            <div class="action-row">
              <button class="btn" data-act="attack" ${dis}>공격</button>
              <button class="btn" data-act="defend" ${dis}>방어</button>
              <button class="btn" data-act="counter" ${dis}>역공격</button>
              <button class="btn" data-act="dodge" ${dis}>회피</button>
              <button class="btn" data-act="item" ${dis}>아이템</button>
              <button class="btn btn-pass" data-act="pass" ${dis}>턴 넘기기</button>
            </div>
            <div class="ready-row">
              <button class="ready-btn ${p.isReady ? 'on':''}" data-act="ready">${p.isReady ? '준비 완료':'전투 준비'}</button>
            </div>
          `;
        }

        return `
          <div class="pcard" ${dead ? 'style="opacity:.65; filter:grayscale(0.15)"' : ''} data-player-id="${p.id}">
            <div class="pc-grid">
              <div class="ring" style="--hp:${hpPct}">
                <div class="avatar" ${avatarStyle}></div>
              </div>
              <div>
                <div class="pname">${esc(p.name||'플레이어')}${dead ? '<span class="badge-dead">사망</span>':''}</div>
                <div class="psub">${statsLine}</div>
                <div class="hpbar" aria-label="HP"><div class="fill" style="--w:${hpPct}%"></div></div>
                <div class="psub" style="margin-top:4px;">HP ${p.hp ?? 0} / ${p.maxHp ?? 100} (${hpPct}%)</div>
                ${actionArea}
              </div>
              <div><span class="tag">${teamKey.toUpperCase()}</span></div>
            </div>
          </div>
        `;
      }).join('') || `<div class="muted">플레이어 없음</div>`;

      // bind action buttons for me
      root.querySelectorAll('.pcard .action-row .btn, .pcard .ready-row .ready-btn').forEach(btn => {
        btn.addEventListener('click', onActionButton);
      });
    };

    renderList('team1', '#team1List');
    renderList('team2', '#team2List');
  }

  function renderLog(b){
    const log = $('#logScroll');
    log.innerHTML = (b.battleLog || [])
      .map(e => `<div class="logline"><span class="t">[${fmtTime(e.timestamp)}]</span>${esc(e.message || '')}</div>`)
      .join('');
    log.scrollTop = log.scrollHeight;
  }

  function renderChat(b){
    appendChat(b.chatLog || [], true);
  }

  function appendChat(list, replace = false){
    const chat = $('#chatScroll');
    const teamOnly = $('#viewTeamOnly').checked;

    const rows = (list || [])
      .filter(c => teamOnly ? c.channel === 'team' : true)
      .map(c => {
        const tag =
          c.senderType === 'admin' ? '<span class="tag tag-admin">ADMIN</span>' :
          (c.channel === 'team' ? '<span class="tag tag-team">TEAM</span>' : '<span class="tag">CHAT</span>');
        return `<div class="logline"><span class="t">[${fmtTime(c.timestamp)}]</span>${tag} <b>${esc(c.sender||'-')}</b>: ${esc(c.message||'')}</div>`;
      }).join('');

    if(replace){
      chat.innerHTML = rows;
    } else {
      chat.insertAdjacentHTML('beforeend', rows);
    }
    chat.scrollTop = chat.scrollHeight;
  }

  // ===== Actions =====
  function onActionButton(e){
    const el = e.currentTarget;
    const act = el.dataset.act;
    if(!act) return;
    if(actionLock) return;

    if(act === 'ready'){
      try {
        socket.emit('playerReady', { ready: !el.classList.contains('on') });
      } catch(_) {}
      return;
    }

    if(act === 'attack'){
      // select enemy target
      pendingAction = { type: 'attack', scope: 'enemy' };
      openTargetModal('공격 대상 선택', collectTargets('enemy'));
      return;
    }

    if(act === 'item'){
      // 간단 구현: 서버 인벤토리를 모름 → 서버가 처리하도록 타입만 보낼 수도 있으나
      // 여기선 아이템이 대상 필요시 아군/적군 선택 모달 열기 예시로 구현
      // 아이템 목록을 서버 상태에서 내 플레이어를 찾아 구성
      const me = findMe(currentBattle);
      if(!me || !Array.isArray(me.inventory) || me.inventory.length === 0){
        // 아이템 없음이면 알림
        alert('사용 가능한 아이템이 없습니다.');
        return;
      }
      // 간단 선택 UI
      const pick = prompt(`아이템을 입력하세요:\n${me.inventory.join(', ')}`);
      if(!pick) return;
      const itemType = pick.trim();

      // 대상 필요 여부 휴리스틱
      const needsAllyTarget = /디터니|회복|힐|치유/i.test(itemType);
      const needsEnemyTarget = /폭탄|포션|독|저주/i.test(itemType);

      if(needsAllyTarget){
        pendingAction = { type: 'item', scope: 'ally', itemType };
        openTargetModal('아이템 사용 대상(아군) 선택', collectTargets('ally'));
        return;
      }
      if(needsEnemyTarget){
        pendingAction = { type: 'item', scope: 'enemy', itemType };
        openTargetModal('아이템 사용 대상(적군) 선택', collectTargets('enemy'));
        return;
      }
      // 대상 불필요
      emitAction({ type: 'item', itemType });
      return;
    }

    if(act === 'defend'){
      emitAction({ type: 'defend' });
      return;
    }

    if(act === 'counter'){
      // 역공격: 방어 대신 피해를 모두 받고 상대에게 피해를 주는 특수 액션
      emitAction({ type: 'counter' });
      return;
    }

    if(act === 'dodge'){
      emitAction({ type: 'dodge' });
      return;
    }

    if(act === 'pass'){
      emitAction({ type: 'pass' });
      return;
    }
  }

  function emitAction(payload){
    if(!socket || socket.disconnected) return alert('연결이 끊어졌습니다.');
    if(actionLock) return;
    actionLock = true;
    try{
      socket.emit('playerAction', { battleId, playerId: myId, action: payload });
    }catch(e){
      actionLock = false;
      alert('행동 전송 실패');
    }
  }

  // ===== Target selection =====
  function collectTargets(scope){
    if(!currentBattle) return [];
    const all = [
      ...(currentBattle.teams?.team1?.players || []),
      ...(currentBattle.teams?.team2?.players || []),
    ].filter(p => p.alive !== false);

    const me = all.find(p => p.id === myId);
    if(!me) return [];

    if(scope === 'enemy'){
      return all.filter(p => p.team !== me.team);
    } else {
      return all.filter(p => p.team === me.team);
    }
  }

  function openTargetModal(title, targets){
    if(!targets || targets.length === 0){
      alert('선택 가능한 대상이 없습니다.');
      pendingAction = null;
      return;
    }
    $('#targetTitle').textContent = title;
    const root = $('#targetList');
    root.innerHTML = targets.map(t => {
      const hpPct = Math.max(0, Math.min(100, Math.round((t.hp ?? 0) * 100 / (t.maxHp || 100))));
      const avatarStyle = t.imageUrl ? `style="--avatar: url('${esc(t.imageUrl)}');"` : '';
      return `
        <button class="target-btn" data-id="${t.id}">
          <span class="ring" style="--hp:${hpPct}"><span class="avatar" ${avatarStyle}></span></span>
          <span style="text-align:left;">
            <div style="font-weight:700">${esc(t.name || '플레이어')}</div>
            <div style="font-size:12px; color:var(--text-muted)">HP ${t.hp ?? 0}/${t.maxHp ?? 100} (${hpPct}%)</div>
          </span>
        </button>
      `;
    }).join('');
    root.querySelectorAll('.target-btn').forEach(btn => {
      btn.addEventListener('click', () => chooseTarget(btn.dataset.id));
    });
    $('#targetModal').classList.add('show');
  }

  function chooseTarget(id){
    const act = pendingAction;
    pendingAction = null;
    $('#targetModal').classList.remove('show');
    if(!act) return;

    if(act.type === 'attack'){
      emitAction({ type: 'attack', targetId: id });
      return;
    }
    if(act.type === 'item'){
      const payload = { type: 'item', itemType: act.itemType, targetId: id };
      emitAction(payload);
      return;
    }
  }

  $('#btnTargetCancel').addEventListener('click', () => {
    pendingAction = null;
    $('#targetModal').classList.remove('show');
  });

  // ===== Chat =====
  function sendChat(){
    const el = $('#chatInput');
    let msg = el.value.trim();
    if(!msg) return;

    let channel = 'all';
    if(/^\/t\b/i.test(msg)){
      channel = 'team';
      msg = msg.replace(/^\/t\b\s*/i, '');
      if(!msg) return;
    }

    if(!socket || socket.disconnected) return alert('연결이 끊어졌습니다.');
    socket.emit('chatMessage', { message: msg, channel });
    el.value = '';
  }

  // ===== Utils =====
  function findMe(b){
    if(!b) return null;
    const all = [
      ...(b.teams?.team1?.players || []),
      ...(b.teams?.team2?.players || []),
    ];
    return all.find(p => p.id === myId) || null;
  }

  function copyCurrentLink(){
    const u = new URL(location.href);
    u.searchParams.set('battle', battleId || '');
    u.searchParams.set('token',  playerOtp || '');
    u.searchParams.set('name',   $('#playerName').value.trim() || '');
    u.searchParams.set('team',   $('#teamSel').value);
    if(myId) u.searchParams.set('pid', myId);
    const avatar = $('#avatarUrl').value.trim();
    if(avatar) u.searchParams.set('avatar', avatar);
    navigator.clipboard.writeText(u.toString()).then(() => {
      alert('링크가 복사되었습니다.');
    }).catch(() => alert('복사 실패'));
  }

  // ===== Bindings =====
  $('#btnJoin').addEventListener('click', () => {
    if(!battleId || !playerOtp){
      alert('전투 ID와 OTP를 입력하세요.');
      return;
    }
    joinBattle();
  });

  $('#btnSendChat').addEventListener('click', sendChat);
  $('#chatInput').addEventListener('keydown', (e) => {
    if(e.key === 'Enter'){ e.preventDefault(); sendChat(); }
  });

  $('#btnCopyLink').addEventListener('click', copyCurrentLink);
  $('#viewTeamOnly').addEventListener('change', () => {
    if(currentBattle) renderChat(currentBattle);
  });

  // ===== Boot from query =====
  (function boot(){
    const p = qs();
    if(p.battle) $('#battleId').value = p.battle, battleId = p.battle;
    if(p.token)  $('#otp').value = p.token, playerOtp = p.token;
    if(p.name)   $('#playerName').value = p.name;
    if(p.team)   $('#teamSel').value = (p.team === 'team2' ? 'team2' : 'team1');
    if(p.avatar) $('#avatarUrl').value = p.avatar;
    if(p.pid)    myId = p.pid;

    // 자동 입장
    if(battleId && playerOtp && ($('#playerName').value || p.pid)){
      // pid가 있으면 서버에 등록된 플레이어로 간주
      if(p.pid){
        connectSocket();
      } else {
        joinBattle();
      }
      $('#auth').classList.add('hidden');
      $('#main').classList.remove('hidden');
      getBattle(battleId).then(b => { currentBattle = b; hydrateUI(b); }).catch(()=>{});
    }
  })();
})();
</script>
</body>
</html>
