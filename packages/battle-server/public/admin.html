<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PYXIS 관리자</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/pyxis-unified.css">
</head>
<body>
  <header class="header">
    <div class="header-content">
      <a href="/" class="logo">PYXIS</a>
      <div class="header-right">
        <span class="text-muted">관리자 콘솔</span>
      </div>
    </div>
  </header>

  <div class="container">
    <div class="admin-grid">
      <!-- 전투 제어 패널 -->
      <div class="card">
        <div class="card-header">
          <h3 class="card-title">전투 제어</h3>
        </div>
        
        <div class="form-group">
          <label class="form-label">전투 모드</label>
          <select id="battleMode" class="form-select">
            <option value="1v1">1v1</option>
            <option value="2v2" selected>2v2</option>
            <option value="3v3">3v3</option>
            <option value="4v4">4v4</option>
          </select>
        </div>

        <div class="form-group">
          <button id="btnCreate" class="btn" style="width: 100%;">전투 생성</button>
        </div>

        <div class="form-group">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
            <button id="btnStart" class="btn">시작</button>
            <button id="btnPause" class="btn">일시정지</button>
          </div>
        </div>

        <div class="form-group">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
            <button id="btnResume" class="btn">재개</button>
            <button id="btnEnd" class="btn danger">종료</button>
          </div>
        </div>

        <div class="form-group">
          <div id="battleStatus" class="status-pill waiting">전투 상태: 대기 중</div>
        </div>

        <hr style="border: none; border-top: 1px solid var(--border-subtle); margin: 20px 0;">

        <!-- 참가자 추가 -->
        <div class="card-header">
          <h4 class="card-title">참가자 추가</h4>
        </div>

        <div class="form-group">
          <label class="form-label">이름</label>
          <input id="playerName" type="text" class="form-input" placeholder="참가자 이름">
        </div>

        <div class="form-group">
          <label class="form-label">팀</label>
          <select id="playerTeam" class="form-select">
            <option value="A">A팀</option>
            <option value="B">B팀</option>
          </select>
        </div>

        <div class="form-group">
          <label class="form-label">HP</label>
          <input id="playerHP" type="number" class="form-input" value="100" min="1" max="200">
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 16px;">
          <div>
            <label class="form-label">공격</label>
            <input id="playerAttack" type="number" class="form-input" value="1" min="1" max="5">
          </div>
          <div>
            <label class="form-label">방어</label>
            <input id="playerDefense" type="number" class="form-input" value="1" min="1" max="5">
          </div>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 16px;">
          <div>
            <label class="form-label">민첩</label>
            <input id="playerAgility" type="number" class="form-input" value="1" min="1" max="5">
          </div>
          <div>
            <label class="form-label">행운</label>
            <input id="playerLuck" type="number" class="form-input" value="1" min="1" max="5">
          </div>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 16px;">
          <div>
            <label class="form-label">디터니</label>
            <input id="playerDittany" type="number" class="form-input" value="0" min="0" max="9">
          </div>
          <div>
            <label class="form-label">공격보정</label>
            <input id="playerAttackBooster" type="number" class="form-input" value="0" min="0" max="9">
          </div>
          <div>
            <label class="form-label">방어보정</label>
            <input id="playerDefenseBooster" type="number" class="form-input" value="0" min="0" max="9">
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">이미지 업로드</label>
          <div style="display: flex; gap: 8px; align-items: center;">
            <button id="avatarPickBtn" class="btn small">파일 선택</button>
            <input id="avatarUpload" type="file" accept="image/*" style="display: none;">
            <img id="avatarPreview" style="width: 32px; height: 32px; border-radius: 4px; background: var(--surface-dark);">
          </div>
        </div>

        <div class="form-group">
          <button id="btnAddPlayer" class="btn" style="width: 100%;">참가자 추가</button>
        </div>

        <hr style="border: none; border-top: 1px solid var(--border-subtle); margin: 20px 0;">

        <!-- 링크 생성 -->
        <div class="card-header">
          <h4 class="card-title">링크 생성</h4>
        </div>

        <div class="form-group">
          <button id="btnGenPlayerLinks" class="btn" style="width: 100%;">전체 링크 생성</button>
        </div>
      </div>

      <!-- 팀 로스터 및 전투 상태 -->
      <div style="display: grid; grid-template-rows: auto 1fr; gap: 20px;">
        <!-- 팀 목록 -->
        <div class="card">
          <div class="card-header">
            <h3 class="card-title">팀 목록</h3>
          </div>
          <div class="teams">
            <div class="team">
              <div class="team-title">A팀</div>
              <div id="teamAContainer" class="roster">
                <div class="empty-team">팀원 없음</div>
              </div>
            </div>
            <div class="team">
              <div class="team-title">B팀</div>
              <div id="teamBContainer" class="roster">
                <div class="empty-team">팀원 없음</div>
              </div>
            </div>
          </div>
        </div>

        <!-- 생성된 링크 -->
        <div class="card">
          <div class="card-header">
            <h3 class="card-title">생성된 링크</h3>
          </div>
          <div id="linksContainer">
            <div class="text-muted text-center">링크를 생성해주세요</div>
          </div>
        </div>
      </div>

      <!-- 로그 및 채팅 -->
      <div style="display: grid; grid-template-rows: 1fr auto; gap: 20px;">
        <!-- 실시간 로그 -->
        <div class="card">
          <div class="card-header">
            <h3 class="card-title">실시간 로그</h3>
          </div>
          <div id="logContainer" class="timeline"></div>
        </div>

        <!-- 채팅 -->
        <div class="card">
          <div class="card-header">
            <h3 class="card-title">채팅</h3>
          </div>
          <div class="chat-wrap">
            <div id="chatContainer" class="chat-messages"></div>
            <div class="chat-input">
              <input id="chatInput" type="text" class="form-input" placeholder="메시지 입력...">
              <button id="chatSend" class="btn">전송</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- 전투 종료 화면 -->
  <div id="gameOverOverlay" class="game-over-overlay">
    <div class="game-over-content">
      <h2 class="game-over-title">전투 종료</h2>
      <div class="game-over-winner">
        <span id="winnerTeam">A팀</span> 승리!
      </div>
      <button id="restartBtn" class="btn mt-2">새 전투 시작</button>
    </div>
  </div>

  <style>
    .game-over-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .game-over-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .game-over-content {
      text-align: center;
      background: var(--glass-2);
      border: 2px solid var(--gold-1);
      border-radius: 16px;
      padding: 32px;
      max-width: 400px;
      width: 90%;
    }

    .game-over-title {
      font-family: 'Cinzel', serif;
      color: var(--gold-1);
      font-size: 24px;
      margin-bottom: 16px;
    }

    .game-over-winner {
      font-size: 18px;
      font-weight: 700;
      color: var(--ink);
      margin-bottom: 20px;
    }
  </style>

  <script src="/socket.io/socket.io.js"></script>
  <script>
(function(){
  'use strict';
  
  // Socket 연결 개선
  let socket;
  let currentBattleId = null;
  let battleState = null;
  let uploadedAvatarUrl = null;
  let connectionRetries = 0;
  const maxRetries = 5;

  // DOM 요소들
  const playerName = document.getElementById('playerName');
  const playerTeam = document.getElementById('playerTeam');
  const playerHP = document.getElementById('playerHP');
  const playerAttack = document.getElementById('playerAttack');
  const playerDefense = document.getElementById('playerDefense');
  const playerAgility = document.getElementById('playerAgility');
  const playerLuck = document.getElementById('playerLuck');
  const playerDittany = document.getElementById('playerDittany');
  const playerAttackBooster = document.getElementById('playerAttackBooster');
  const playerDefenseBooster = document.getElementById('playerDefenseBooster');
  const avatarUpload = document.getElementById('avatarUpload');

  // Socket 연결 함수 개선
  function initializeSocket() {
    try {
      // 기존 연결이 있으면 정리
      if (socket) {
        socket.removeAllListeners();
        socket.disconnect();
      }

      // 새 소켓 연결
      socket = io({
        path: '/socket.io',
        transports: ['websocket', 'polling'],
        upgrade: true,
        rememberUpgrade: true,
        timeout: 20000,
        forceNew: true
      });

      setupSocketEvents();
      
    } catch (error) {
      console.error('소켓 초기화 실패:', error);
      addLog({ts: Date.now(), type: 'error', message: '서버 연결 초기화 실패'});
    }
  }

  function setupSocketEvents() {
    socket.on('connect', () => {
      console.log('서버에 연결되었습니다');
      connectionRetries = 0;
      addLog({ts: Date.now(), type: 'notice', message: '서버에 연결되었습니다'});
      
      // 기존 전투가 있으면 재입장
      if (currentBattleId) {
        socket.emit('join', { battleId: currentBattleId });
      }
    });

    socket.on('disconnect', (reason) => {
      console.log('서버 연결이 끊어졌습니다:', reason);
      addLog({ts: Date.now(), type: 'error', message: '서버 연결이 끊어졌습니다: ' + reason});
      
      // 자동 재연결 시도
      if (connectionRetries < maxRetries) {
        connectionRetries++;
        setTimeout(() => {
          addLog({ts: Date.now(), type: 'notice', message: `재연결 시도 중... (${connectionRetries}/${maxRetries})`});
          initializeSocket();
        }, 2000 * connectionRetries);
      }
    });

    socket.on('connect_error', (error) => {
      console.error('연결 오류:', error);
      addLog({ts: Date.now(), type: 'error', message: '서버 연결 오류: ' + error.message});
    });

    // 전투 상태 업데이트
    const onSnap = (snap) => {
      battleState = snap;
      render();
    };
    socket.on('battleUpdate', onSnap);
    socket.on('battle:update', onSnap);

    // 로그 수신
    socket.on('battle:log', addLog);
    socket.on('battleLog', addLog);

    // 채팅 수신
    socket.on('chatMessage', addChat);
    socket.on('battle:chat', addChat);

    // 전투 종료
    socket.on('battle:ended', (d) => {
      addLog({ts: Date.now(), type: 'notice', message: `${d.winner}팀 승리!`});
      showGameOverOverlay(d.winner);
    });
  }

  // 유틸리티 함수들
  function esc(str) {
    return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
  }

  function fixUrl(url) {
    if (!url) return '';
    return url.replace(/([^:]\/)\/+/g, '$1');
  }

  // 로그 시스템 (기존 유지)
  function getLogClass(log) {
    const type = log.type || 'system';
    const message = log.message || '';
    
    switch (type) {
      case 'gold':
        return 'gold';
      case 'teamA':
        return 'teamA';
      case 'teamB':
        return 'teamB';
      case 'system':
        return 'system';
      case 'error':
        return 'error';
      case 'notice':
        return 'notice';
      default:
        if (message.includes('선공 결정:') || 
            message.includes('팀이 선공입니다!') || 
            message.includes('전투가 시작되었습니다!') || 
            message.includes('라운드 시작') || 
            message.includes('라운드 종료') ||
            message.includes('승리!')) {
          return 'gold';
        }
        
        if (message.includes('=== A팀') || 
            message.includes('[A]') || 
            message.includes('A팀 선택')) {
          return 'teamA';
        }
        
        if (message.includes('=== B팀') || 
            message.includes('[B]') || 
            message.includes('B팀 선택')) {
          return 'teamB';
        }
        
        return 'system';
    }
  }

  function formatLogTime(timestamp) {
    const date = new Date(timestamp);
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    const seconds = date.getSeconds().toString().padStart(2, '0');
    return `${hours}시 ${minutes}분 ${seconds}초`;
  }

  function addLog(log) {
    if (!log) return;
    
    const timeStr = formatLogTime(log.ts);
    const logClass = getLogClass(log);
    const message = esc(log.message || '');
    
    const logHtml = `
      <div class="tl-line ${logClass}">
        <span class="log-time">[${timeStr}]</span>
        <span class="log-content">${message}</span>
      </div>
    `;
    
    const container = document.getElementById('logContainer');
    if (container) {
      container.insertAdjacentHTML('beforeend', logHtml);
      container.scrollTop = container.scrollHeight;
    }
  }

  function renderLogs() {
    const container = document.getElementById('logContainer');
    if (!container || !battleState?.logs) return;
    
    container.innerHTML = '';
    battleState.logs.forEach(log => {
      const timeStr = formatLogTime(log.ts);
      const logClass = getLogClass(log);
      const message = esc(log.message || '');
      
      const logHtml = `
        <div class="tl-line ${logClass}">
          <span class="log-time">[${timeStr}]</span>
          <span class="log-content">${message}</span>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', logHtml);
    });
    
    container.scrollTop = container.scrollHeight;
  }

  // 채팅 시스템
  function addChat(chat) {
    if (!chat) return;
    
    const timeStr = formatLogTime(chat.ts);
    const name = esc(chat.name || '');
    const message = esc(chat.message || '');
    
    const chatHtml = `
      <div class="chat-line">
        <span class="log-time">[${timeStr}]</span>
        <span class="chat-name">${name}:</span> ${message}
      </div>
    `;
    
    const container = document.getElementById('chatContainer');
    if (container) {
      container.insertAdjacentHTML('beforeend', chatHtml);
      container.scrollTop = container.scrollHeight;
    }
  }

  // 전투 제어 함수들 (안전장치 추가)
  function createBattle() {
    if (!socket || !socket.connected) {
      addLog({ts: Date.now(), type: 'error', message: '서버에 연결되지 않았습니다'});
      return;
    }

    const mode = document.getElementById('battleMode').value;
    socket.emit('createBattle', { mode }, (response) => {
      if (response?.ok) {
        currentBattleId = response.battleId;
        addLog({ts: Date.now(), type: 'notice', message: '전투가 생성되었습니다'});
        socket.emit('join', { battleId: currentBattleId });
      } else {
        addLog({ts: Date.now(), type: 'error', message: '전투 생성 실패: ' + (response?.error || '알 수 없는 오류')});
      }
    });
  }

  function startBattle() {
    if (!currentBattleId || !socket?.connected) return;
    socket.emit('startBattle', { battleId: currentBattleId }, (response) => {
      if (!response?.ok) {
        addLog({ts: Date.now(), type: 'error', message: '전투 시작 실패: ' + (response?.error || '알 수 없는 오류')});
      }
    });
  }

  function pauseBattle() {
    if (!currentBattleId || !socket?.connected) return;
    socket.emit('pauseBattle', { battleId: currentBattleId }, (response) => {
      if (!response?.ok) {
        addLog({ts: Date.now(), type: 'error', message: '일시정지 실패: ' + (response?.error || '알 수 없는 오류')});
      }
    });
  }

  function resumeBattle() {
    if (!currentBattleId || !socket?.connected) return;
    socket.emit('resumeBattle', { battleId: currentBattleId }, (response) => {
      if (!response?.ok) {
        addLog({ts: Date.now(), type: 'error', message: '재개 실패: ' + (response?.error || '알 수 없는 오류')});
      }
    });
  }

  function endBattle() {
    if (!currentBattleId || !socket?.connected) return;
    if (!confirm('정말로 전투를 종료하시겠습니까?')) return;
    socket.emit('endBattle', { battleId: currentBattleId }, (response) => {
      if (!response?.ok) {
        addLog({ts: Date.now(), type: 'error', message: '종료 실패: ' + (response?.error || '알 수 없는 오류')});
      }
    });
  }

  // 아바타 업로드
  function uploadAvatar(file) {
    const formData = new FormData();
    formData.append('avatar', file);
    
    fetch('/api/upload/avatar', {
      method: 'POST',
      body: formData
    })
    .then(r => r.json())
    .then(d => {
      if (d.ok) {
        uploadedAvatarUrl = d.url;
        addLog({ts: Date.now(), type: 'notice', message: '이미지가 업로드되었습니다'});
      } else {
        throw new Error(d.error || '업로드 실패');
      }
    })
    .catch(e => {
      addLog({ts: Date.now(), type: 'error', message: '이미지 업로드 실패: ' + e.message});
    });
  }

  // 참가자 관리
  function addPlayer() {
    if (!currentBattleId) {
      addLog({ts: Date.now(), type: 'error', message: '먼저 전투를 생성해주세요'});
      return;
    }

    if (!socket?.connected) {
      addLog({ts: Date.now(), type: 'error', message: '서버에 연결되지 않았습니다'});
      return;
    }

    const name = playerName.value.trim();
    if (!name) {
      addLog({ts: Date.now(), type: 'error', message: '이름을 입력해주세요'});
      return;
    }

    const team = playerTeam.value;
    const hp = parseInt(playerHP.value) || 100;
    const attack = parseInt(playerAttack.value) || 1;
    const defense = parseInt(playerDefense.value) || 1;
    const agility = parseInt(playerAgility.value) || 1;
    const luck = parseInt(playerLuck.value) || 1;
    const dittany = parseInt(playerDittany.value) || 0;
    const attackBooster = parseInt(playerAttackBooster.value) || 0;
    const defenseBooster = parseInt(playerDefenseBooster.value) || 0;

    const playerData = {
      name, team, hp, maxHp: hp,
      stats: { attack, defense, agility, luck },
      items: { dittany, attackBooster, defenseBooster },
      avatar: uploadedAvatarUrl
    };

    socket.emit('addPlayer', { battleId: currentBattleId, player: playerData }, (res) => {
      if (res?.ok) {
        addLog({ts: Date.now(), type: 'notice', message: `${name}이(가) ${team}팀에 추가되었습니다`});
        clearPlayerForm();
      } else {
        addLog({ts: Date.now(), type: 'error', message: '참가자 추가 실패: ' + (res?.error || '알 수 없는 오류')});
      }
    });
  }

  function removePlayer(playerId) {
    if (!currentBattleId || !playerId || !socket?.connected) return;
    const p = battleState?.players?.find(x => x.id === playerId);
    const nm = p?.name || 'Unknown';
    if (!confirm(`${nm}을(를) 제거하시겠습니까?`)) return;
    socket.emit('deletePlayer', { battleId: currentBattleId, playerId }, (res) => {
      if (res?.ok) {
        addLog({ts: Date.now(), type: 'notice', message: `${nm}이(가) 제거되었습니다`});
      } else {
        addLog({ts: Date.now(), type: 'error', message: '참가자 제거 실패: ' + (res?.error || '알 수 없는 오류')});
      }
    });
  }

  function clearPlayerForm() {
    playerName.value = '';
    playerTeam.value = 'A';
    playerHP.value = '100';
    playerAttack.value = '1';
    playerDefense.value = '1';
    playerAgility.value = '1';
    playerLuck.value = '1';
    playerDittany.value = '0';
    playerAttackBooster.value = '0';
    playerDefenseBooster.value = '0';
    avatarUpload.value = '';
    uploadedAvatarUrl = null;
    document.getElementById('avatarPreview').removeAttribute('src');
  }

  // 링크 생성
  function generateLinks() {
    if (!currentBattleId) {
      addLog({ts: Date.now(), type: 'error', message: '먼저 전투를 생성해주세요'});
      return;
    }
    
    fetch(`/api/admin/battles/${currentBattleId}/links`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'}
    })
    .then(r => {
      if (!r.ok) {
        return fetch(`/api/battles/${currentBattleId}/links`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'}
        });
      }
      return r;
    })
    .then(r => r.json())
    .then(d => {
      const payload = d?.links || d;
      if (payload?.spectator && (payload.players || payload.playerLinks)) {
        displayLinks(payload);
        addLog({ts: Date.now(), type: 'notice', message: '링크가 생성되었습니다'});
      } else {
        throw new Error('링크 데이터가 올바르지 않습니다');
      }
    })
    .catch(e => {
      console.error('링크 생성 실패:', e);
      addLog({ts: Date.now(), type: 'error', message: '링크 생성 실패: ' + e.message});
    });
  }

  function displayLinks(data) {
    const container = document.getElementById('linksContainer');
    let html = '';
    
    if (data.spectator?.url) {
      const sp = fixUrl(data.spectator.url);
      html += `<div class="link-item">
        <div class="link-label">관전자 링크</div>
        <div class="link-url" onclick="copyToClipboard('${sp}', event)">${sp}</div>
        <button class="copy-btn" onclick="copyToClipboard('${sp}', event)">복사</button>
      </div>`;
    }
    
    const playerList = data.players || data.playerLinks || [];
    if (Array.isArray(playerList)) {
      playerList.forEach(link => {
        const url = fixUrl(link.url);
        const labelName = link.name || link.playerName || '참가자';
        html += `<div class="link-item">
          <div class="link-label">${esc(labelName)} (${esc(link.team||'')}팀)</div>
          <div class="link-url" onclick="copyToClipboard('${url}', event)">${url}</div>
          <button class="copy-btn" onclick="copyToClipboard('${url}', event)">복사</button>
        </div>`;
      });
    }
    
    container.innerHTML = html;
  }

  // 클립보드 복사
  window.copyToClipboard = function(text, ev) {
    navigator.clipboard.writeText(text).then(() => {
      if (ev && ev.target) {
        const btn = ev.target.tagName === 'BUTTON' ? ev.target : ev.currentTarget;
        const orig = btn.textContent;
        btn.textContent = '복사됨!';
        btn.style.background = '#16a34a';
        setTimeout(() => {
          btn.textContent = orig;
          btn.style.background = '';
        }, 900);
      } else {
        addLog({ts: Date.now(), type: 'notice', message: '클립보드에 복사되었습니다'});
      }
    }).catch(() => {
      addLog({ts: Date.now(), type: 'error', message: '복사 실패'});
    });
  };

  // 채팅 전송
  function sendChat() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    if (!message || !currentBattleId || !socket?.connected) return;
    socket.emit('chatMessage', { battleId: currentBattleId, name: '관리자', message });
    input.value = '';
  }

  // 팀 렌더링
  function renderTeams() {
    if (!battleState?.players) return;
    
    const teamA = battleState.players.filter(p => p.team === 'A');
    const teamB = battleState.players.filter(p => p.team === 'B');
    
    function renderTeam(players, containerId, teamName) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      if (players.length === 0) {
        container.innerHTML = '<div class="empty-team">팀원 없음</div>';
        return;
      }
      
      let html = '';
      players.forEach(p => {
        const hpPct = Math.max(0, (p.hp / (p.maxHp || 100)) * 100);
        const readyStatus = p.ready ? '준비완료' : '대기중';
        const aliveStatus = p.hp > 0 ? '' : ' (전투불능)';
        
        html += `
          <div class="player-card ${p.hp > 0 ? '' : 'dead'}">
            <div class="pc-header">
              <img src="${p.avatar || ''}" class="pc-avatar" alt="${esc(p.name)}"
                   onerror="this.style.background='#333';this.removeAttribute('src')"/>
              <div class="pc-info">
                <div class="pc-name">${esc(p.name)}${aliveStatus}</div>
                <div class="pc-ready">${readyStatus}</div>
              </div>
              <button onclick="removePlayer('${p.id}')" class="btn-remove" title="제거">×</button>
            </div>
            <div class="pc-hp">
              <div class="hp-bar">
                <div class="hp-fill" style="width: ${hpPct}%"></div>
              </div>
              <div class="hp-text">HP ${p.hp}/${p.maxHp || 100}</div>
            </div>
            <div class="pc-stats">
              공격 ${p.stats?.attack || 0} | 방어 ${p.stats?.defense || 0} | 
              민첩 ${p.stats?.agility || 0} | 행운 ${p.stats?.luck || 0}
            </div>
            <div class="pc-items">
              디터니 ${p.items?.dittany || p.items?.ditany || 0} | 
              공격보정 ${p.items?.attackBooster || p.items?.attack_boost || 0} | 
              방어보정 ${p.items?.defenseBooster || p.items?.defense_boost || 0}
            </div>
          </div>
        `;
      });
      
      container.innerHTML = html;
    }
    
    renderTeam(teamA, 'teamAContainer', 'A팀');
    renderTeam(teamB, 'teamBContainer', 'B팀');
  }

  // 전체 렌더링
  function render() {
    if (!battleState) return;
    
    // 전투 상태 표시
    const statusElement = document.getElementById('battleStatus');
    if (statusElement) {
      const statusText = {
        waiting: '대기 중',
        active: '진행 중',
        paused: '일시정지',
        ended: '종료됨'
      }[battleState.status] || '알 수 없음';
      
      statusElement.textContent = `전투 상태: ${statusText}`;
      statusElement.className = `status-pill ${battleState.status}`;
    }
    
    // 팀 로스터 렌더링
    renderTeams();
    
    // 로그 렌더링
    renderLogs();
  }

  // 게임 종료 처리
  function showGameOverOverlay(winner) {
    const overlay = document.getElementById('gameOverOverlay');
    const winnerTeam = document.getElementById('winnerTeam');
    winnerTeam.textContent = winner + '팀';
    overlay.classList.add('show');
    document.body.classList.add('battle-ended');
  }

  // 이벤트 리스너들
  document.getElementById('btnCreate').addEventListener('click', createBattle);
  document.getElementById('btnStart').addEventListener('click', startBattle);
  document.getElementById('btnPause').addEventListener('click', pauseBattle);
  document.getElementById('btnResume').addEventListener('click', resumeBattle);
  document.getElementById('btnEnd').addEventListener('click', endBattle);

  document.getElementById('btnAddPlayer').addEventListener('click', addPlayer);
  document.getElementById('avatarPickBtn').addEventListener('click', () => avatarUpload.click());
  document.getElementById('avatarUpload').addEventListener('change', (e) => {
    if (e.target.files[0]) {
      const blob = URL.createObjectURL(e.target.files[0]);
      document.getElementById('avatarPreview').src = blob;
      uploadAvatar(e.target.files[0]);
    }
  });

  document.getElementById('btnGenPlayerLinks').addEventListener('click', generateLinks);

  document.getElementById('chatSend').addEventListener('click', sendChat);
  document.getElementById('chatInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      sendChat();
    }
  });

  document.getElementById('restartBtn').addEventListener('click', () => {
    createBattle();
    document.getElementById('gameOverOverlay').classList.remove('show');
  });

  // 전역 함수로 등록
  window.removePlayer = removePlayer;

  // URL 파라미터에서 battleId 확인
  const qs = new URLSearchParams(location.search);
  const bid = qs.get('battle');
  if (bid) {
    currentBattleId = bid;
  }

  // 초기화
  initializeSocket();
  
  // 초기 로그
  addLog({ts: Date.now(), type: 'system', message: 'PYXIS 관리자 콘솔이 시작되었습니다'});

})();
  </script>
</body>
</html>
