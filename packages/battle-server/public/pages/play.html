<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PYXIS 전투 - 플레이어</title>

  <!-- 폰트 -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />

  <style>
    /* ═══════════════════════════════════════════════════════════════════════
       PYXIS Battle System - 게임 스타일 플레이어 페이지 (네이비+골드)
       이모지 없음 / 기존 디자인 유지 / 잘린 부분 보완 완료
       + 네트워크 내구성 패치(소켓 로더/하트비트/ACK) 반영 버전
       ═══════════════════════════════════════════════════════════════════════ */

    :root {
      /* 핵심 색상 */
      --deep-navy: #00080D;
      --navy-light: #001E35;
      --navy-hover: #002A4B;
      --gold-bright: #DCC7A2;
      --gold-warm: #D4BA8D;
      --gold-pale: rgba(220, 199, 162, 0.1);
      --gold-glow: rgba(220, 199, 162, 0.3);

      /* 상태 색상 */
      --success: #22C55E;
      --warning: #F59E0B;
      --danger: #EF4444;
      --info: #3B82F6;
      --critical: #DC2626;

      /* 텍스트 색상 */
      --text-bright: #FFFFFF;
      --text-normal: #E2E8F0;
      --text-muted: #94A3B8;
      --text-dim: #64748B;

      /* 배경 및 표면 */
      --surface-1: rgba(0, 30, 53, 0.8);
      --surface-2: rgba(0, 30, 53, 0.6);
      --surface-3: rgba(0, 42, 75, 0.7);
      --border-subtle: rgba(220, 199, 162, 0.2);
      --border-bright: rgba(220, 199, 162, 0.4);

      /* 효과 */
      --blur-light: blur(8px);
      --blur-strong: blur(16px);
      --shadow-card: 0 4px 20px rgba(0, 8, 13, 0.5);
      --shadow-hover: 0 8px 32px rgba(220, 199, 162, 0.2);

      /* 폰트 */
      --font-display: 'Cinzel', serif;
      --font-body: 'Inter', sans-serif;

      /* 간격 */
      --space-xs: 0.25rem;
      --space-sm: 0.5rem;
      --space-md: 1rem;
      --space-lg: 1.5rem;
      --space-xl: 2rem;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: var(--font-body);
      background: linear-gradient(135deg, var(--deep-navy) 0%, var(--navy-light) 100%);
      color: var(--text-normal);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* 배경 장식 효과 */
    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle at 20% 30%, var(--gold-pale) 0%, transparent 50%),
                  radial-gradient(circle at 80% 70%, rgba(220, 199, 162, 0.05) 0%, transparent 50%);
      animation: slowRotate 80s linear infinite;
      pointer-events: none;
      z-index: -1;
    }

    @keyframes slowRotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    /* 헤더 */
    .pyxis-header {
      background: linear-gradient(135deg, var(--surface-1) 0%, var(--surface-2) 50%, var(--surface-1) 100%);
      backdrop-filter: var(--blur-strong);
      border-bottom: 2px solid transparent;
      border-image: linear-gradient(90deg, transparent, var(--gold-bright), transparent) 1;
      padding: var(--space-sm) var(--space-md);
      text-align: center;
      position: sticky; top: 0; z-index: 100; overflow: hidden; position: relative;
    }

    .pyxis-header::before {
      content: '';
      position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent 0%, rgba(220,199,162,0.1) 25%, rgba(220,199,162,0.2) 50%, rgba(220,199,162,0.1) 75%, transparent 100%);
      animation: headerShimmer 5s infinite;
    }
    @keyframes headerShimmer { 0% { left: -100%; } 100% { left: 100%; } }

    .pyxis-title {
      font-family: var(--font-display);
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--gold-bright), var(--gold-warm), var(--gold-bright));
      background-size: 200% 200%;
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
      letter-spacing: 0.1em; position: relative; z-index: 1;
      animation: titleGradient 4s ease-in-out infinite alternate;
    }
    @keyframes titleGradient { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }

    /* 연결 상태 */
    .connection-status {
      position: fixed; top: var(--space-sm); right: var(--space-sm);
      background: var(--surface-1); border: 1px solid var(--border-subtle);
      border-radius: 20px; padding: var(--space-xs) var(--space-sm);
      backdrop-filter: var(--blur-light); z-index: 200; display: flex; align-items: center; gap: var(--space-xs);
      font-size: 0.8rem;
    }
    .connection-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--success); animation: pulse 2s infinite; }
    .connection-dot.disconnected { background: var(--danger); animation: none; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

    /* 인증 섹션 */
    .auth-section { display: flex; justify-content: center; align-items: center; min-height: 60vh; padding: var(--space-md); }
    .auth-card { background: var(--surface-1); backdrop-filter: var(--blur-light); border: 1px solid var(--border-subtle); border-radius: 16px; padding: var(--space-xl); box-shadow: var(--shadow-card); width: 100%; max-width: 400px; text-align: center; }
    .auth-title { font-family: var(--font-display); font-size: 1.5rem; font-weight: 600; color: var(--text-bright); margin-bottom: var(--space-lg); background: linear-gradient(135deg, var(--gold-bright), var(--gold-warm)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .auth-form { display: grid; gap: var(--space-md); }
    .auth-input { padding: var(--space-md); background: var(--surface-2); border: 1px solid var(--border-subtle); border-radius: 8px; color: var(--text-bright); font-size: 1rem; transition: all 0.3s ease; }
    .auth-input:focus { outline: none; border-color: var(--gold-bright); box-shadow: 0 0 0 2px var(--gold-glow); }
    .auth-input::placeholder { color: var(--text-muted); }
    .auth-submit { padding: var(--space-md); background: linear-gradient(135deg, var(--gold-bright), var(--gold-warm)); color: var(--deep-navy); border: none; border-radius: 8px; font-weight: 700; font-size: 1rem; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.05em; }
    .auth-submit:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(220, 199, 162, 0.4); }
    .auth-message { margin-top: var(--space-md); padding: var(--space-sm); border-radius: 6px; font-size: 0.9rem; text-align: center; }
    .auth-message.success { background: rgba(34, 197, 94, 0.2); color: var(--success); border: 1px solid rgba(34, 197, 94, 0.3); }
    .auth-message.error { background: rgba(239, 68, 68, 0.2); color: var(--danger); border: 1px solid rgba(239, 68, 68, 0.3); }
    .auth-message.info { background: rgba(59, 130, 246, 0.2); color: var(--info); border: 1px solid rgba(59, 130, 246, 0.3); }

    /* 메인 레이아웃 */
    .player-layout { display: grid; grid-template-columns: 300px 1fr 250px; gap: var(--space-md); padding: var(--space-md); min-height: calc(100vh - 80px); }
    @media (max-width: 1200px) { .player-layout { grid-template-columns: 1fr; gap: var(--space-sm); } }

    /* 플레이어 카드 */
    .player-card { background: var(--surface-1); backdrop-filter: var(--blur-light); border: 1px solid var(--border-subtle); border-radius: 12px; overflow: hidden; box-shadow: var(--shadow-card); transition: all 0.3s ease; position: relative; }
    .player-card::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, var(--gold-bright), var(--gold-warm)); opacity: 0; transition: opacity 0.3s ease; }
    .player-card:hover::before { opacity: 1; }
    .player-header { padding: var(--space-md); background: var(--surface-2); border-bottom: 1px solid var(--border-subtle); text-align: center; }
    .player-avatar { width: 60px; height: 60px; border-radius: 50%; background: var(--gold-bright); color: var(--deep-navy); display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1.5rem; margin: 0 auto var(--space-sm); position: relative; }
    .player-avatar::after { content: ''; position: absolute; inset: -3px; border-radius: 50%; background: linear-gradient(45deg, var(--gold-bright), var(--gold-warm)); z-index: -1; opacity: 0; transition: opacity 0.3s ease; }
    .player-avatar:hover::after { opacity: 1; }
    .player-name { font-family: var(--font-display); font-size: 1.2rem; font-weight: 600; color: var(--text-bright); margin-bottom: var(--space-xs); }
    .player-team { font-size: 0.85rem; color: var(--gold-bright); background: var(--gold-pale); padding: var(--space-xs) var(--space-sm); border-radius: 20px; display: inline-block; }
    .player-content { padding: var(--space-md); }

    /* HP */
    .hp-section { margin-bottom: var(--space-lg); }
    .hp-label { font-size: 0.8rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: var(--space-xs); }
    .hp-bar { height: 24px; background: var(--surface-3); border-radius: 12px; overflow: hidden; position: relative; border: 1px solid var(--border-subtle); }
    .hp-fill { height: 100%; background: linear-gradient(90deg, var(--success), var(--warning)); transition: width 0.5s ease; position: relative; }
    .hp-fill::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent); animation: shimmer 2s infinite; }
    @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
    .hp-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: 700; font-size: 0.9rem; color: var(--text-bright); text-shadow: 0 1px 2px rgba(0,0,0,0.5); }

    /* 스탯 */
    .stats-section { margin-bottom: var(--space-lg); }
    .section-title { font-size: 0.9rem; font-weight: 600; color: var(--text-bright); margin-bottom: var(--space-sm); text-transform: uppercase; letter-spacing: 0.05em; }
    .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-sm); }
    .stat-item { background: var(--surface-2); padding: var(--space-sm); border-radius: 8px; text-align: center; border: 1px solid var(--border-subtle); transition: all 0.3s ease; }
    .stat-item:hover { background: var(--surface-3); border-color: var(--border-bright); }
    .stat-name { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: var(--space-xs); }
    .stat-value { font-size: 1.2rem; font-weight: 700; color: var(--gold-bright); }

    /* 아이템 */
    .items-grid { display: grid; gap: var(--space-xs); }
    .item { background: var(--surface-2); padding: var(--space-sm); border-radius: 6px; border: 1px solid var(--border-subtle); display: flex; justify-content: space-between; align-items: center; transition: all 0.3s ease; }
    .item:hover { background: var(--surface-3); border-color: var(--border-bright); }
    .item-name { font-size: 0.8rem; color: var(--text-normal); }
    .item-count { font-weight: 700; color: var(--gold-bright); background: var(--gold-pale); padding: 2px var(--space-xs); border-radius: 10px; font-size: 0.7rem; }

    /* 전투 영역 */
    .battle-main { display: grid; grid-template-rows: auto auto 1fr; gap: var(--space-md); }
    .battle-status { background: var(--surface-1); backdrop-filter: var(--blur-light); border: 1px solid var(--border-subtle); border-radius: 12px; padding: var(--space-md); box-shadow: var(--shadow-card); }
    .battle-info { display: grid; grid-template-columns: repeat(4, 1fr); gap: var(--space-sm); text-align: center; }
    .battle-stat { display: flex; flex-direction: column; gap: 2px; }
    .battle-stat-label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; }
    .battle-stat-value { font-size: 1.1rem; font-weight: 700; color: var(--text-bright); }
    .battle-stat-value.active { color: var(--success); }
    .battle-stat-value.warning { color: var(--warning); }
    .battle-stat-value.danger { color: var(--danger); }

    /* 타이머 */
    .turn-timer { background: var(--surface-1); backdrop-filter: var(--blur-light); border: 1px solid var(--border-subtle); border-radius: 12px; padding: var(--space-md); text-align: center; }
    .timer-label { font-size: 0.8rem; color: var(--text-muted); margin-bottom: var(--space-xs); }
    .timer-value { font-size: 2rem; font-weight: 700; color: var(--gold-bright); font-family: 'Courier New', monospace; }
    .timer-value.critical { color: var(--critical); animation: timerPulse 1s infinite; }
    @keyframes timerPulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }

    /* 액션 */
    .action-panel { background: var(--surface-1); backdrop-filter: var(--blur-light); border: 1px solid var(--border-subtle); border-radius: 12px; padding: var(--space-md); box-shadow: var(--shadow-card); }
    .section-title { font-size: 0.9rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; }
    .action-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: var(--space-sm); margin-top: var(--space-sm); }
    .action-btn { padding: var(--space-md); background: linear-gradient(135deg, var(--surface-2), var(--surface-3)); border: 1px solid var(--border-subtle); border-radius: 8px; color: var(--text-bright); font-weight: 600; cursor: pointer; transition: all 0.3s ease; position: relative; overflow: hidden; text-align: center; }
    .action-btn::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(220,199,162,0.2), transparent); transition: left 0.6s ease; }
    .action-btn:hover { background: linear-gradient(135deg, var(--gold-bright), var(--gold-warm)); color: var(--deep-navy); border-color: var(--gold-bright); transform: translateY(-2px); box-shadow: 0 6px 16px rgba(220, 199, 162, 0.3); }
    .action-btn:hover::before { left: 100%; }
    .action-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .action-btn:disabled:hover { background: linear-gradient(135deg, var(--surface-2), var(--surface-3)); color: var(--text-bright); transform: none; box-shadow: none; }
    .action-text { font-size: 0.9rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; }
    .action-desc { font-size: 0.7rem; opacity: 0.8; margin-top: 2px; }

    /* 채팅 & 로그 */
    .log-chat-section { display: grid; gap: var(--space-md); }
    .chat-container, .log-container { background: var(--surface-1); backdrop-filter: var(--blur-light); border: 1px solid var(--border-subtle); border-radius: 12px; overflow: hidden; box-shadow: var(--shadow-card); }
    .chat-header, .log-header { padding: var(--space-sm) var(--space-md); background: var(--surface-2); border-bottom: 1px solid var(--border-subtle); font-size: 0.9rem; font-weight: 600; color: var(--text-bright); text-transform: uppercase; letter-spacing: 0.05em; }
    .chat-messages, .log-content { height: 180px; overflow-y: auto; padding: var(--space-sm); }
    .chat-entry, .log-entry { padding: var(--space-xs); margin-bottom: var(--space-xs); border-radius: 4px; font-size: 0.8rem; line-height: 1.3; }
    .chat-entry { background: var(--surface-2); }
    .chat-entry.my-message { background: var(--gold-pale); border-left: 2px solid var(--gold-bright); }
    .log-entry { background: var(--surface-2); border-left: 2px solid var(--info); }
    .log-entry.combat { border-left-color: var(--danger); }
    .log-entry.system { border-left-color: var(--warning); }
    .chat-input-section { padding: var(--space-sm); background: var(--surface-2); border-top: 1px solid var(--border-subtle); display: flex; gap: var(--space-xs); }
    .chat-input { flex: 1; padding: var(--space-sm); background: var(--surface-3); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--text-bright); font-size: 0.8rem; }
    .chat-input:focus { outline: none; border-color: var(--gold-bright); }
    .chat-send { padding: var(--space-sm) var(--space-md); background: var(--gold-bright); color: var(--deep-navy); border: none; border-radius: 6px; font-weight: 600; font-size: 0.8rem; cursor: pointer; transition: all 0.3s ease; }
    .chat-send:hover { background: var(--gold-warm); }

    /* 대상 선택 모달 */
    .target-modal { position: fixed; inset: 0; background: rgba(0, 8, 13, 0.8); backdrop-filter: var(--blur-strong); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: all 0.3s ease; }
    .target-modal.show { opacity: 1; visibility: visible; }
    .target-content { background: var(--surface-1); border: 1px solid var(--border-bright); border-radius: 16px; padding: var(--space-xl); max-width: 400px; width: 90%; box-shadow: var(--shadow-hover); }
    .target-title { font-family: var(--font-display); font-size: 1.3rem; font-weight: 600; color: var(--text-bright); text-align: center; margin-bottom: var(--space-lg); }
    .target-list { display: grid; gap: var(--space-sm); margin-bottom: var(--space-lg); }
    .target-option { padding: var(--space-md); background: var(--surface-2); border: 1px solid var(--border-subtle); border-radius: 8px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: var(--space-md); }
    .target-option:hover { background: var(--surface-3); border-color: var(--gold-bright); }
    .target-avatar { width: 40px; height: 40px; border-radius: 50%; background: var(--gold-bright); color: var(--deep-navy); display: flex; align-items: center; justify-content: center; font-weight: 700; }
    .target-info { flex: 1; }
    .target-name { font-weight: 600; color: var(--text-bright); margin-bottom: 2px; }
    .target-hp { font-size: 0.8rem; color: var(--text-muted); }
    .target-actions { display: flex; gap: var(--space-sm); justify-content: center; }
    .target-cancel, .target-confirm { padding: var(--space-sm) var(--space-lg); border-radius: 6px; border: none; font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
    .target-cancel { background: var(--surface-3); color: var(--text-normal); border: 1px solid var(--border-subtle); }
    .target-cancel:hover { background: var(--surface-2); }
    .target-confirm { background: var(--gold-bright); color: var(--deep-navy); }
    .target-confirm:hover { background: var(--gold-warm); }

    /* 스크롤바 */
    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-track { background: var(--surface-2); }
    ::-webkit-scrollbar-thumb { background: var(--gold-bright); border-radius: 2px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--gold-warm); }

    /* 유틸 클래스 */
    .hidden { display: none !important; }
    .disabled { pointer-events: none; opacity: 0.5; }

    /* 토스트 */
    .toast { position: fixed; top: var(--space-md); right: var(--space-md); background: var(--surface-1); border: 1px solid var(--border-bright); border-radius: 8px; padding: var(--space-sm) var(--space-md); color: var(--text-bright); font-size: 0.85rem; backdrop-filter: var(--blur-light); z-index: 2000; transform: translateX(100%); transition: transform 0.3s ease; }
    .toast.show { transform: translateX(0); }
    .toast.success { border-color: var(--success); }
    .toast.error { border-color: var(--danger); }
    .toast.warning { border-color: var(--warning); }
    .toast.info { border-color: var(--info); }

    /* 반응형 */
    @media (max-width: 1200px) {
      .player-layout { grid-template-columns: 1fr; }
      .battle-info { grid-template-columns: repeat(2, 1fr); }
      .action-grid { grid-template-columns: 1fr; }
    }
    @media (max-width: 768px) {
      .pyxis-title { font-size: 1.2rem; }
      .player-layout { padding: var(--space-sm); gap: var(--space-sm); }
      .player-avatar { width: 50px; height: 50px; }
      .stats-grid { grid-template-columns: 1fr; }
      .battle-info { grid-template-columns: 1fr; }
      .timer-value { font-size: 1.5rem; }
      .chat-messages, .log-content { height: 120px; }
      .target-content { padding: var(--space-lg); }
    }
  </style>
</head>
<body>
  <!-- 헤더 -->
  <header class="pyxis-header">
    <h1 class="pyxis-title">PYXIS 전투</h1>
  </header>

  <!-- 연결 상태 -->
  <div class="connection-status">
    <div class="connection-dot" id="connectionDot"></div>
    <span id="connectionText">연결됨</span>
  </div>

  <!-- 인증 섹션 -->
  <section class="auth-section" id="authSection">
    <div class="auth-card">
      <h2 class="auth-title">전투 입장</h2>
      <form class="auth-form" id="authForm">
        <input type="text" class="auth-input" id="battleId" placeholder="전투 ID" required />
        <input type="text" class="auth-input" id="playerOtp" placeholder="플레이어 OTP" required />
        <input type="text" class="auth-input" id="playerName" placeholder="플레이어 이름" required maxlength="20" />
        <button type="submit" class="auth-submit">입장</button>
      </form>
      <div class="auth-message hidden" id="authMessage"></div>
    </div>
  </section>

  <!-- 메인 플레이어 UI -->
  <main class="player-layout hidden" id="playerUI">
    <!-- 내 정보 -->
    <aside class="player-card">
      <div class="player-header">
        <div class="player-avatar" id="myAvatar">P</div>
        <div class="player-name" id="myName">플레이어</div>
        <div class="player-team" id="myTeam">팀</div>
      </div>
      <div class="player-content">
        <!-- HP 바 -->
        <div class="hp-section">
          <div class="hp-label">체력</div>
          <div class="hp-bar">
            <div class="hp-fill" id="myHpFill" style="width: 100%"></div>
            <div class="hp-text" id="myHpText">50/50</div>
          </div>
        </div>

        <!-- 스탯 -->
        <div class="stats-section">
          <div class="section-title">능력치</div>
          <div class="stats-grid">
            <div class="stat-item"><div class="stat-name">공격</div><div class="stat-value" id="statAttack">3</div></div>
            <div class="stat-item"><div class="stat-name">방어</div><div class="stat-value" id="statDefense">3</div></div>
            <div class="stat-item"><div class="stat-name">민첩</div><div class="stat-value" id="statAgility">3</div></div>
            <div class="stat-item"><div class="stat-name">행운</div><div class="stat-value" id="statLuck">3</div></div>
          </div>
        </div>

        <!-- 아이템 -->
        <div class="items-section">
          <div class="section-title">아이템</div>
          <div class="items-grid">
            <div class="item" id="itemDittany"><span class="item-name">디터니</span><span class="item-count">0</span></div>
            <div class="item" id="itemAttackBoost"><span class="item-name">공격 보정기</span><span class="item-count">0</span></div>
            <div class="item" id="itemDefenseBoost"><span class="item-name">방어 보정기</span><span class="item-count">0</span></div>
          </div>
        </div>
      </div>
    </aside>

    <!-- 전투 현황 및 액션 -->
    <section class="battle-main">
      <div class="battle-status">
        <div class="battle-info">
          <div class="battle-stat"><div class="battle-stat-label">전투 ID</div><div class="battle-stat-value" id="battleIdDisplay">-</div></div>
          <div class="battle-stat"><div class="battle-stat-label">턴</div><div class="battle-stat-value" id="currentTurn">1</div></div>
          <div class="battle-stat"><div class="battle-stat-label">페이즈</div><div class="battle-stat-value" id="currentPhase">대기</div></div>
          <div class="battle-stat"><div class="battle-stat-label">상태</div><div class="battle-stat-value active" id="battleStatus">진행중</div></div>
        </div>
      </div>

      <!-- 턴 타이머 -->
      <div class="turn-timer">
        <div class="timer-label">남은 시간</div>
        <div class="timer-value" id="turnTimer">5:00</div>
      </div>

      <!-- 액션 패널 -->
      <div class="action-panel">
        <div class="section-title">행동 선택</div>
        <div class="action-grid" id="actionGrid">
          <button class="action-btn" id="btnAttack" data-action="attack"><div class="action-text">공격</div><div class="action-desc">적을 공격합니다</div></button>
          <button class="action-btn" id="btnDefend" data-action="defend"><div class="action-text">방어</div><div class="action-desc">방어하고 역공합니다</div></button>
          <button class="action-btn" id="btnDodge" data-action="dodge"><div class="action-text">회피</div><div class="action-desc">회피율을 높입니다</div></button>
          <button class="action-btn" id="btnUseItem" data-action="item"><div class="action-text">아이템</div><div class="action-desc">아이템을 사용합니다</div></button>
          <button class="action-btn" id="btnPass" data-action="pass"><div class="action-text">패스</div><div class="action-desc">턴을 넘깁니다</div></button>
        </div>
      </div>
    </section>

    <!-- 채팅 및 로그 -->
    <aside class="log-chat-section">
      <div class="chat-container">
        <div class="chat-header">채팅</div>
        <div class="chat-messages" id="chatMessages"><div class="chat-entry"><strong>시스템:</strong> 채팅이 시작되었습니다.</div></div>
        <div class="chat-input-section">
          <input type="text" class="chat-input" id="chatInput" placeholder="메시지 입력..." maxlength="200" />
          <button class="chat-send" id="chatSend">전송</button>
        </div>
      </div>

      <div class="log-container">
        <div class="log-header">전투 로그</div>
        <div class="log-content" id="logContent">
          <div class="log-entry system">시스템 초기화 완료</div>
          <div class="log-entry">전투 준비 중...</div>
        </div>
      </div>
    </aside>
  </main>

  <!-- 대상 선택 모달(내장 폴백) -->
  <div class="target-modal" id="targetModal">
    <div class="target-content">
      <h3 class="target-title" id="targetTitle">대상 선택</h3>
      <div class="target-list" id="targetList"></div>
      <div class="target-actions">
        <button class="target-cancel" id="targetCancel">취소</button>
      </div>
    </div>
  </div>

  <!-- Socket.IO 로더 (origin → CDN 폴백) -->
  <script>
    (function ensureSocketIO(){
      if (window.io) {
        document.dispatchEvent(new Event('socket-io-ready'));
        return;
      }
      function add(src, onload, onerror){
        var s=document.createElement('script');
        s.src=src; s.async=true; s.onload=onload; s.onerror=onerror;
        document.head.appendChild(s);
      }
      add('/socket.io/socket.io.js',
        function(){ document.dispatchEvent(new Event('socket-io-ready')); },
        function(){ add('https://cdn.socket.io/4.7.5/socket.io.min.js',
          function(){ document.dispatchEvent(new Event('socket-io-ready')); },
          function(){ console.warn('[PYXIS] Socket.IO client load failed'); }
        );}
      );
    })();
  </script>

  <!-- 플레이어 스크립트 -->
  <script>
    // ===== 전역 상태/도움 함수
    let socket = null;
    const $ = (id) => document.getElementById(id);

    const playerState = {
      battleId: null,
      playerId: null,
      playerName: null,
      playerOtp: null,
      team: null,
      isAuthenticated: false,
      battleStatus: 'waiting',
      currentTurn: 1,
      currentPhase: 'waiting',
      isMyTurn: false,
      canAct: false,
      myPlayer: null,
      allPlayers: [],
      teammates: [],
      enemies: [],
      selectedAction: null,
      actionInProgress: false,
      turnTimeLeft: 0
    };

    let turnTimer = null;
    let turnAutoPassed = false;

    // Heartbeat / stale-connection detection
    let hb = null, hbTimeout = null, lastPong = 0;
    const HEARTBEAT_EVERY = 15000;      // ms
    const CONN_TIMEOUT_MS = 12000;      // ms

    // ===== 초기화: io 준비 신호를 기다린 뒤 부트스트랩
    document.addEventListener('DOMContentLoaded', function() {
      initializeFromUrl();

      if (window.io) {
        initializeSocket();
        setupEventListeners();
      } else {
        document.addEventListener('socket-io-ready', () => {
          initializeSocket();
          setupEventListeners();
        }, { once: true });
      }
    });

    // URL 파라미터 → 폼 채움 & 자동 로그인 시도
    function initializeFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const battleId   = params.get('battleId') || params.get('battle');
      const playerName = params.get('name')     || params.get('playerName');
      const playerOtp  = params.get('otp')      || params.get('token');

      if (battleId)   $('battleId').value   = battleId;
      if (playerName) $('playerName').value = playerName;
      if (playerOtp)  $('playerOtp').value  = playerOtp;

      if (battleId && playerName && playerOtp) {
        setTimeout(() => {
          $('authForm').dispatchEvent(new Event('submit'));
        }, 200);
      }
    }

    // ===== 소켓 초기화 (+이벤트 호환 레이어)
    function initializeSocket() {
      socket = io();

      socket.on('connect', function() {
        updateConnectionStatus(true);
        startHeartbeat(); // 하트비트 시작

        // 재접속 후 상태 동기화
        if (playerState.isAuthenticated && playerState.battleId && playerState.playerId) {
          requestGameState();
        }
      });

      socket.on('disconnect', function() {
        updateConnectionStatus(false);
        stopHeartbeat(); // 하트비트 정지
        showToast('서버 연결이 끊어졌습니다', 'error');
      });

      // Heartbeat pong (서버 이벤트명 호환)
      socket.on('player:pong', () => { lastPong = Date.now(); });
      socket.on('pong',        () => { lastPong = Date.now(); });

      // 인증
      socket.on('auth:success', function(data) { handleAuthSuccess(data); });
      socket.on('auth:error',  function(data) { showAuthMessage('인증 실패: ' + (data?.message || '오류'), 'error'); });
      // 호환 이벤트명
      socket.on('authSuccess', function(data) { handleAuthSuccess(data); });
      socket.on('authError',   function(msg)  { showAuthMessage('인증 실패: ' + (msg || '오류'), 'error'); });

      // 상태/업데이트
      socket.on('gameState',    function(data) { updateGameState(data); });
      socket.on('playerUpdate', function(data) { updatePlayerInfo(data); });
      // 호환 이벤트명
      socket.on('state',        function(data) { updateGameState(data); });
      socket.on('state:update', function(data) { updateGameState(data); });
      socket.on('battleUpdate', function(data) { updateGameState(data); });

      // 턴/액션/종료
      socket.on('turnStart',      function(data) { handleTurnStart(data); });
      socket.on('actionResult',   function(data) { handleActionResult(data); });
      socket.on('action:success', function(data) { handleActionResult(data); });
      socket.on('actionSuccess',  function(data) { handleActionResult(data); });
      socket.on('battleEnd',      function(data) { handleBattleEnd(data); });
      socket.on('battle:end',     function(data) { handleBattleEnd(data); });

      // 로그/채팅
      socket.on('battleLog',  function(data) { addLogEntry(data?.message || '', data?.type || 'info'); });
      socket.on('chatMessage',function(data) { addChatMessage(data?.sender || '알 수 없음', data?.message || '', data?.isMyMessage === true); });
      socket.on('chat:new',   function(msg)  { addChatMessage(msg?.nickname || msg?.from?.nickname || '익명', msg?.text || '', false); });
    }

    function startHeartbeat(){
      stopHeartbeat();
      lastPong = Date.now();
      hb = setInterval(() => {
        if (!socket?.connected) return;
        socket.emit('player:ping', { t: Date.now() });
        clearTimeout(hbTimeout);
        hbTimeout = setTimeout(() => {
          if (Date.now() - lastPong > CONN_TIMEOUT_MS) {
            try { socket.disconnect(); } catch {}
          }
        }, CONN_TIMEOUT_MS + 100);
      }, HEARTBEAT_EVERY);
    }
    function stopHeartbeat(){
      if (hb) clearInterval(hb);
      if (hbTimeout) clearTimeout(hbTimeout);
      hb = null; hbTimeout = null;
    }

    function requestGameState() {
      if (!socket || !playerState.battleId) return;
      // 다양한 서버 구현과 호환
      socket.emit('requestGameState', { battleId: playerState.battleId, playerId: playerState.playerId });
      socket.emit('requestState',     { battleId: playerState.battleId, playerId: playerState.playerId });
      // 세션 재등록 겸 최신 상태 유도
      socket.emit('session:init',     { role: 'player', battleId: playerState.battleId, playerId: playerState.playerId });
    }

    // ===== 이벤트 리스너
    function setupEventListeners() {
      // 인증 폼
      $('authForm').addEventListener('submit', function(e) {
        e.preventDefault();
        handleAuth();
      });

      // 액션 버튼
      document.querySelectorAll('.action-btn').forEach(btn => {
        btn.addEventListener('click', function() { selectAction(this.dataset.action); });
      });

      // 채팅
      $('chatSend').addEventListener('click', sendChatMessage);
      $('chatInput').addEventListener('keypress', function(e) { if (e.key === 'Enter') sendChatMessage(); });

      // 대상 모달
      $('targetCancel').addEventListener('click', hideTargetModal);

      // 단축키 (모달 열려 있으면 무시)
      document.addEventListener('keydown', function(e) {
        if ($('authSection').classList.contains('hidden')) {
          if (isTargetModalOpen()) return;
          handleKeyboardShortcut(e);
        }
      });

      // 페이지 종료/가시성
      window.addEventListener('beforeunload', cleanup);
      document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
          stopTurnTimer();
        } else if (playerState.isAuthenticated && playerState.battleId) {
          requestGameState();
        }
      });

      // 터치 최적화
      if ('ontouchstart' in window) {
        document.addEventListener('touchstart', function(){}, { passive: true });
        document.querySelectorAll('.action-btn').forEach(btn => {
          btn.addEventListener('touchend', function(e) { e.preventDefault(); });
        });
      }

      // HTTPS에서 서비스워커 등록(옵션)
      if ('serviceWorker' in navigator && window.location.protocol === 'https:') {
        navigator.serviceWorker.register('/sw.js').catch(()=>{});
      }
    }

    function cleanup() {
      if (turnTimer) clearInterval(turnTimer);
      stopHeartbeat();
      if (socket) socket.disconnect();
    }

    // ===== 연결 상태 UI
    function updateConnectionStatus(connected) {
      const dot = $('connectionDot');
      const text = $('connectionText');
      if (connected) { dot.classList.remove('disconnected'); text.textContent = '연결됨'; }
      else { dot.classList.add('disconnected'); text.textContent = '연결 끊김'; }
    }

    // ===== 인증
    function handleAuth() {
      const battleId   = $('battleId').value.trim();
      const playerName = $('playerName').value.trim();
      const playerOtp  = $('playerOtp').value.trim();
      if (!battleId || !playerName || !playerOtp) { showAuthMessage('모든 필드를 입력해주세요', 'error'); return; }
      playerState.battleId = battleId; playerState.playerName = playerName; playerState.playerOtp = playerOtp;
      showAuthMessage('인증 중...', 'info');
      socket.emit('auth:login', { role: 'player', battleId, otp: playerOtp, playerName });
    }

    function handleAuthSuccess(data) {
      playerState.isAuthenticated = true;
      playerState.playerId = data.playerId || data.selfPid || data.player?.id || data.selfPid;
      playerState.team     = data.team || data.player?.team || null;

      showAuthMessage('인증 성공!', 'success');
      setTimeout(() => {
        $('authSection').classList.add('hidden');
        $('playerUI').classList.remove('hidden');
        updatePlayerDisplay();
        // 세션 초기화 및 상태 요청
        requestGameState();
      }, 500);
    }

    function showAuthMessage(message, type) {
      const el = $('authMessage');
      el.textContent = message; el.className = `auth-message ${type}`; el.classList.remove('hidden');
    }

    // ===== 상태 업데이트
    function normalizePlayers(players) {
      if (!players) return [];
      if (Array.isArray(players)) return players.slice();
      // 객체 맵 형태 {id: player, ...}
      return Object.keys(players).map(id => ({ id, ...players[id] }));
    }

    function mergePlayer(oldP, newP) {
      if (!oldP) return newP;
      return { ...oldP, ...newP, stats: { ...(oldP.stats||{}), ...(newP.stats||{}) }, items: { ...(oldP.items||{}), ...(newP.items||{}) } };
    }

    function updateGameState(data) {
      if (data.battleId) playerState.battleId = data.battleId;
      if (data.status)   playerState.battleStatus = data.status;
      if (data.turn !== undefined) playerState.currentTurn = data.turn;
      if (data.phase)    playerState.currentPhase = data.phase;

      // players: 배열/맵 모두 지원
      if (data.players) {
        const arr = normalizePlayers(data.players);
        playerState.allPlayers = arr;

        // 내 플레이어
        let me = arr.find(p => p.id === playerState.playerId);
        // 혹시 서버가 selfPid만 주는 경우를 대비
        if (!me && data.selfPid) me = arr.find(p => p.id === data.selfPid);
        if (me) playerState.myPlayer = mergePlayer(playerState.myPlayer, me);

        const myTeam = me ? (me.team) : playerState.team;
        playerState.teammates = arr.filter(p => p.team === myTeam);
        playerState.enemies   = arr.filter(p => p.team !== myTeam);
      }

      updateBattleDisplay();
      updatePlayerDisplay();
      updateActionButtons();
    }

    function updatePlayerInfo(data) {
      const p = data.player || data;
      if (!p) return;
      if (p.id === playerState.playerId) {
        playerState.myPlayer = mergePlayer(playerState.myPlayer, p);
        updatePlayerDisplay();
      }
      // 전체 목록 갱신
      if (Array.isArray(playerState.allPlayers)) {
        const idx = playerState.allPlayers.findIndex(x => x.id === p.id);
        if (idx >= 0) playerState.allPlayers[idx] = mergePlayer(playerState.allPlayers[idx], p);
      }
    }

    // ===== 표시 업데이트
    function safeStat(p, key) {
      // 호환: stats.attack|atk, defense|def, agility|agi, luck|luk
      const s = p.stats || {};
      switch (key) {
        case 'attack':  return (s.attack ?? p.attack ?? p.atk ?? 0);
        case 'defense': return (s.defense ?? p.defense ?? p.def ?? 0);
        case 'agility': return (s.agility ?? p.agility ?? p.agi ?? 0);
        case 'luck':    return (s.luck    ?? p.luck    ?? p.luk ?? 0);
        default: return 0;
      }
    }
    function safeItemCount(p, key) {
      const it = p.items || {};
      // 호환: attackBoost|atkBoost, defenseBoost|defBoost, dittany|Dittany
      switch (key) {
        case 'dittany':     return (it.dittany ?? it.Dittany ?? 0);
        case 'attackBoost': return (it.attackBoost ?? it.atkBoost ?? 0);
        case 'defenseBoost':return (it.defenseBoost ?? it.defBoost ?? 0);
        default: return 0;
      }
    }

    function updatePlayerDisplay() {
      const p = playerState.myPlayer;
      if (!p) return;

      $('myName').textContent = p.name || playerState.playerName || '플레이어';
      $('myTeam').textContent = getTeamName(p.team);
      $('myAvatar').textContent = (p.name ? p.name.charAt(0) : (playerState.playerName||'P').charAt(0)).toUpperCase();

      const maxHp = Number.isFinite(p.maxHp) ? p.maxHp : 100;
      const curHp = Number.isFinite(p.hp) ? p.hp : maxHp;
      const hpPercent = Math.max(0, Math.min(100, (curHp / maxHp) * 100));
      $('myHpFill').style.width = hpPercent + '%';
      $('myHpText').textContent = `${curHp}/${maxHp}`;

      $('statAttack').textContent  = safeStat(p, 'attack');
      $('statDefense').textContent = safeStat(p, 'defense');
      $('statAgility').textContent = safeStat(p, 'agility');
      $('statLuck').textContent    = safeStat(p, 'luck');

      document.querySelector('#itemDittany .item-count').textContent      = safeItemCount(p, 'dittany');
      document.querySelector('#itemAttackBoost .item-count').textContent  = safeItemCount(p, 'attackBoost');
      document.querySelector('#itemDefenseBoost .item-count').textContent = safeItemCount(p, 'defenseBoost');
    }

    function updateBattleDisplay() {
      $('battleIdDisplay').textContent = playerState.battleId || '-';
      $('currentTurn').textContent = playerState.currentTurn ?? '-';
      $('currentPhase').textContent = getPhaseText(playerState.currentPhase);
      $('battleStatus').textContent = getBattleStatusText(playerState.battleStatus);
    }

    // 액션 버튼 상태
    function updateActionButtons() {
      const alive = playerState.myPlayer ? (playerState.myPlayer.alive !== false) : true;
      const canAct = playerState.isMyTurn && playerState.canAct && !playerState.actionInProgress && playerState.battleStatus === 'active' && alive;
      document.querySelectorAll('.action-btn').forEach(btn => {
        btn.disabled = !canAct;
        if (canAct) btn.classList.remove('disabled'); else btn.classList.add('disabled');
      });
    }

    // ===== 턴 시작
    function handleTurnStart(data) {
      playerState.isMyTurn = !!data.isMyTurn;
      playerState.canAct   = !!data.canAct;
      playerState.turnTimeLeft = Number.isFinite(data.timeLimit) ? data.timeLimit : 300; // 기본 5분
      updateActionButtons();

      // 타이머
      if (playerState.isMyTurn) {
        showToast('당신의 턴입니다', 'success');
        startTurnTimer(playerState.turnTimeLeft);
      } else {
        const name = data.currentPlayerName || '상대';
        showToast(name + '의 턴입니다', 'info');
        stopTurnTimer();
      }
    }

    // ===== 액션 선택/실행
    function selectAction(action) {
      if (!playerState.isMyTurn || !playerState.canAct || playerState.actionInProgress) return;
      playerState.selectedAction = action;

      if (action === 'attack') {
        showTargetSelection('공격할 대상을 선택하세요', playerState.enemies, (target) => {
          executeAction('attack', target);
        });
      } else if (action === 'item') {
        showItemSelection();
      } else if (action === 'pass') {
        executeAction('pass');
      } else {
        // defend / dodge 등
        executeAction(action);
      }
    }

    // ACK 우선 처리(빠른 실패 감지). 성공/결과 메시지는 actionResult 이벤트로 수신.
    function executeAction(action, target = null, item = null) {
      if (!playerState.isAuthenticated) return;
      playerState.actionInProgress = true;
      updateActionButtons();

      const payload = {
        battleId: playerState.battleId,
        playerId: playerState.playerId,
        action
      };
      if (target && target.id) {
        payload.targetId = target.id;
        payload.target   = target.id; // 일부 서버 호환
      }
      if (item) {
        payload.item = item;
        payload.itemType = item;
      }

      // 서버가 ACK를 지원하면 즉시 실패를 감지
      socket.emit('playerAction', payload, function(res){
        if (!res || res.success) {
          // 성공 ACK: 실제 결과는 actionResult에서 처리
        } else {
          showToast('액션 실패: ' + (res.error || '오류'), 'error');
          playerState.actionInProgress = false;
          updateActionButtons();
        }
      });

      hideTargetModal();
    }

    // ===== 액션 결과
    function handleActionResult(data) {
      playerState.actionInProgress = false;
      updateActionButtons();

      if (data && data.success) {
        if (data.message) addLogEntry(data.message, 'combat');
      } else {
        showToast('액션 실패: ' + (data?.error || '오류'), 'error');
      }
    }

    // ===== 턴 타이머(자동 패스 포함)
    function startTurnTimer(timeLimit) {
      stopTurnTimer();
      let timeLeft = Math.max(0, Math.floor(timeLimit));
      turnAutoPassed = false;

      const timerEl = $('turnTimer');
      const tick = () => {
        const m = Math.floor(timeLeft / 60);
        const s = timeLeft % 60;
        timerEl.textContent = `${m}:${s.toString().padStart(2, '0')}`;
        if (timeLeft <= 30) timerEl.classList.add('critical'); else timerEl.classList.remove('critical');

        if (timeLeft <= 0) {
          stopTurnTimer();
          if (!turnAutoPassed && playerState.isMyTurn && playerState.canAct) {
            turnAutoPassed = true;
            showToast('시간 초과! 자동으로 패스됩니다', 'warning');
            // 실제 패스 전송
            executeAction('pass');
          }
          return;
        }
        timeLeft--;
      };
      tick();
      turnTimer = setInterval(tick, 1000);
    }
    function stopTurnTimer() {
      if (turnTimer) { clearInterval(turnTimer); turnTimer = null; }
      $('turnTimer').classList.remove('critical');
    }

    // ===== 대상 선택 (PyxisTargetSelector가 있으면 우선 사용)
    function isTargetModalOpen() {
      return $('targetModal').classList.contains('show');
    }
    function showTargetSelection(title, targets, callback) {
      // 외부 고급 셀렉터가 있다면 사용
      if (window.PyxisTarget && typeof window.PyxisTarget.show === 'function') {
        try {
          const norm = (window.PyxisTargetUtils && window.PyxisTargetUtils.normalizeTarget)
            ? targets.map(t => window.PyxisTargetUtils.normalizeTarget(t))
            : targets;
          window.PyxisTarget.show(title, norm, (picked) => callback(picked));
          return; // 내장 모달 사용 안 함
        } catch(e) { /* 실패 시 폴백 */ }
      }

      // ===== 내장 폴백 모달 =====
      $('targetTitle').textContent = title;
      const list = $('targetList');
      list.innerHTML = '';
      (targets || []).forEach(target => {
        const maxHp = Number.isFinite(target.maxHp) ? target.maxHp : 100;
        const curHp = Number.isFinite(target.hp) ? target.hp : maxHp;
        const el = document.createElement('div');
        el.className = 'target-option';
        el.innerHTML = `<div class="target-avatar">${(target.name || '?').charAt(0).toUpperCase()}</div>
                        <div class="target-info">
                          <div class="target-name">${escapeHtml(target.name || 'Unknown')}</div>
                          <div class="target-hp">HP: ${curHp}/${maxHp}</div>
                        </div>`;
        el.addEventListener('click', function() { callback(target); });
        list.appendChild(el);
      });
      $('targetModal').classList.add('show');
    }
    function hideTargetModal() { $('targetModal').classList.remove('show'); }

    // ===== 아이템 선택 (키 호환)
    function showItemSelection() {
      const p = playerState.myPlayer || {};
      const items = p.items || {};
      const menu = [];

      const dittany      = items.dittany ?? items.Dittany ?? 0;
      const attackBoost  = items.attackBoost ?? items.atkBoost ?? 0;
      const defenseBoost = items.defenseBoost ?? items.defBoost ?? 0;

      if (dittany > 0)      menu.push({ type: 'dittany', name: '디터니', desc: 'HP 10 회복' });
      if (attackBoost > 0)  menu.push({ type: 'attackBoost', name: '공격 보정기', desc: '다음 공격 1.5배' });
      if (defenseBoost > 0) menu.push({ type: 'defenseBoost', name: '방어 보정기', desc: '다음 방어 1.5배' });

      if (menu.length === 0) { showToast('사용할 수 있는 아이템이 없습니다', 'warning'); return; }

      $('targetTitle').textContent = '사용할 아이템을 선택하세요';
      const list = $('targetList');
      list.innerHTML = '';
      menu.forEach(item => {
        const el = document.createElement('div');
        el.className = 'target-option';
        el.innerHTML = `<div class="target-avatar">${item.name.charAt(0)}</div>
                        <div class="target-info">
                          <div class="target-name">${item.name}</div>
                          <div class="target-hp">${item.desc}</div>
                        </div>`;
        el.addEventListener('click', function() {
          if (item.type === 'dittany') {
            // 아군 대상 선택
            showTargetSelection('치료할 대상을 선택하세요', playerState.teammates, (target) => { executeAction('item', target, item.type); });
          } else {
            executeAction('item', null, item.type);
          }
        });
        list.appendChild(el);
      });
      $('targetModal').classList.add('show');
    }

    // ===== 채팅
    function sendChatMessage() {
      const input = $('chatInput');
      const message = input.value.trim();
      if (!message || !playerState.isAuthenticated) return;
      socket.emit('chatMessage', { battleId: playerState.battleId, sender: playerState.playerName, message });
      input.value = '';
    }
    function addChatMessage(sender, message, isMyMessage = false) {
      const container = $('chatMessages');
      const div = document.createElement('div');
      div.className = `chat-entry ${isMyMessage ? 'my-message' : ''}`;
      div.innerHTML = `<strong>${escapeHtml(sender)}:</strong> ${escapeHtml(message)}`;
      container.appendChild(div); container.scrollTop = container.scrollHeight;
      while (container.children.length > 50) container.removeChild(container.firstChild);
    }

    // ===== 로그
    function addLogEntry(message, type = 'info') {
      const container = $('logContent');
      const div = document.createElement('div');
      div.className = `log-entry ${type}`;
      const time = new Date().toLocaleTimeString('ko-KR', { hour12:false });
      div.textContent = `[${time}] ${message}`;
      container.appendChild(div); container.scrollTop = container.scrollHeight;
      while (container.children.length > 100) container.removeChild(container.firstChild);
    }

    // ===== 전투 종료
    function handleBattleEnd(data) {
      stopTurnTimer();
      playerState.battleStatus = 'ended';
      playerState.canAct = false; updateActionButtons();
      const isWin = data && (data.winner === playerState.team || data.winnerTeam === playerState.team);
      showToast('전투 종료: ' + (isWin ? '승리' : '패배'), isWin ? 'success' : 'error');
      if (data?.winnerTeam) addLogEntry(`전투 종료: ${data.winnerTeam} 승리`, 'system');
    }

    // ===== 단축키
    function handleKeyboardShortcut(e) {
      if (!playerState.isMyTurn || !playerState.canAct) return;
      switch (e.key) {
        case '1': e.preventDefault(); selectAction('attack'); break;
        case '2': e.preventDefault(); selectAction('defend'); break;
        case '3': e.preventDefault(); selectAction('dodge'); break;
        case '4': e.preventDefault(); selectAction('item'); break;
        case '5': e.preventDefault(); selectAction('pass'); break;
        case 'Enter': if (e.target.id !== 'chatInput') { $('chatInput').focus(); } break;
      }
    }

    // ===== 토스트
    function showToast(message, type = 'info') {
      const existing = document.querySelector('.toast');
      if (existing) existing.remove();
      const toast = document.createElement('div');
      toast.className = `toast ${type}`; toast.textContent = message; document.body.appendChild(toast);
      setTimeout(() => toast.classList.add('show'), 50);
      setTimeout(() => { toast.classList.remove('show'); setTimeout(() => toast.remove(), 300); }, 3000);
    }

    // ===== 유틸
    function getTeamName(team) {
      switch ((team||'').toString()) {
        case 'phoenix':
        case 'A':
        case 'a':
        case 'team1': return '불사조 기사단';
        case 'eaters':
        case 'B':
        case 'b':
        case 'team2': return '죽음을 먹는 자들';
        default: return team || '-';
      }
    }
    function getPhaseText(phase) {
      switch (phase) {
        case 'waiting': return '대기';
        case 'action': return '행동';
        case 'resolution': return '결과';
        case 'active': return '진행';
        case 'ended': return '종료';
        default: return phase || '-';
      }
    }
    function getBattleStatusText(status) {
      switch (status) {
        case 'waiting': return '대기중';
        case 'active': return '진행중';
        case 'paused': return '일시정지';
        case 'ended': return '종료';
        default: return status || '-';
      }
    }
    function escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; }
  </script>
</body>
</html>
