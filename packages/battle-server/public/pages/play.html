<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PYXIS 플레이어</title>
<link rel="icon" type="image/svg+xml" href="/assets/favicon.svg">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700;800;900&family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<link href="/assets/pyxis-theme.css" rel="stylesheet">
<script src="/socket.io/socket.io.js"></script>
<style>
/* PYXIS 플레이어 전용 고급 디자인 스타일 */

/* 헤더 배경 효과 */
.player-header{
  position:relative; 
  padding:40px 20px 20px; 
  overflow:hidden;
  background: linear-gradient(135deg, rgba(10,15,26,.95) 0%, rgba(16,21,35,.98) 100%);
}

.player-header::before{
  content:''; 
  position:absolute; 
  inset:-50% -20% auto -20%; 
  height:400px;
  background: conic-gradient(from 0deg at 50% 50%, 
    rgba(212,183,126,.25) 0deg, 
    rgba(212,183,126,.08) 60deg,
    rgba(212,183,126,.30) 120deg, 
    rgba(212,183,126,.05) 180deg, 
    rgba(212,183,126,.25) 240deg, 
    rgba(212,183,126,.08) 300deg, 
    rgba(212,183,126,.25) 360deg
  );
  filter: blur(80px);
  animation: celestialOrbit 50s linear infinite;
  opacity: .9;
  pointer-events: none;
  z-index: -1;
}

@keyframes celestialOrbit{
  0% { transform: rotate(0deg) scale(1); }
  25% { transform: rotate(90deg) scale(1.1); }
  50% { transform: rotate(180deg) scale(.9); }
  75% { transform: rotate(270deg) scale(1.15); }
  100% { transform: rotate(360deg) scale(1); }
}

/* 브랜드 로고 */
.player-brand{
  font-family: var(--serif); 
  font-weight: 900; 
  letter-spacing: .1em; 
  font-size: 42px;
  background: linear-gradient(135deg, 
    #e6d3aa 0%, 
    #f0e4c5 25%, 
    #d4b77e 50%, 
    #dcc7a2 75%,
    #e6d3aa 100%
  );
  background-size: 300% 300%;
  -webkit-background-clip: text; 
  background-clip: text; 
  -webkit-text-fill-color: transparent;
  animation: brandShimmer 5s ease-in-out infinite;
  position: relative;
  display: inline-block;
  text-shadow: 0 4px 20px rgba(212,183,126,.4);
}

@keyframes brandShimmer{
  0%, 100% {
    background-position: 0% 50%;
    filter: brightness(1);
    transform: scale(1);
  }
  50% {
    background-position: 100% 50%;
    filter: brightness(1.3);
    transform: scale(1.03);
  }
}

.player-brand::before{
  content: '✦';
  position: absolute;
  top: -12px;
  left: -28px;
  font-size: 20px;
  color: #d4b77e;
  animation: starTwinkle 2.5s ease-in-out infinite;
  opacity: .9;
}

.player-brand::after{
  content: '전투자';
  position: absolute;
  top: -10px;
  right: -70px;
  font-size: 14px;
  font-weight: 700;
  color: #d4b77e;
  background: linear-gradient(135deg, rgba(212,183,126,.25), rgba(212,183,126,.12));
  border: 1px solid #d4b77e;
  border-radius: 999px;
  padding: 6px 16px;
  letter-spacing: .03em;
  box-shadow: 0 4px 12px rgba(212,183,126,.2);
}

@keyframes starTwinkle{
  0%, 100% { opacity: .4; transform: scale(.8) rotate(0deg); }
  50% { opacity: 1; transform: scale(1.4) rotate(180deg); }
}

/* 레이아웃 */
.player-stage{
  display: grid; 
  grid-template-columns: 300px 1fr 360px; 
  gap: 24px; 
  padding: 20px 24px;
  max-width: 1600px;
  margin: 0 auto;
}

@media (max-width: 1400px){
  .player-stage{
    grid-template-columns: 1fr;
    gap: 18px;
    padding: 16px 20px;
  }
}

/* 인증 섹션 */
.auth-section{
  background: linear-gradient(145deg, 
    rgba(212,183,126,.12) 0%, 
    rgba(16,21,35,.95) 20%, 
    rgba(26,32,44,.90) 100%
  );
  border: 2px solid #d4b77e; 
  border-radius: var(--radius-large); 
  padding: 32px; 
  text-align: center; 
  backdrop-filter: blur(20px);
  box-shadow: 
    0 20px 40px rgba(0,0,0,.3), 
    inset 0 2px 0 rgba(212,183,126,.3),
    0 0 30px rgba(212,183,126,.15);
  position: relative; 
  overflow: hidden;
}

.auth-section::before{ 
  content: ''; 
  position: absolute; 
  inset: 0; 
  background: linear-gradient(135deg, 
    rgba(212,183,126,.15), 
    transparent 40%, 
    rgba(212,183,126,.08)
  ); 
  opacity: .7; 
}

.auth-title{ 
  font-family: var(--serif); 
  font-size: 32px; 
  font-weight: 800; 
  color: #e6d3aa; 
  margin-bottom: 24px; 
  position: relative; 
  text-shadow: 0 3px 12px rgba(212,183,126,.4);
}

/* 플레이어 정보 바 */
.player-info-bar{
  background: linear-gradient(145deg, 
    rgba(16,21,35,.95) 0%, 
    rgba(26,32,44,.92) 50%, 
    rgba(16,21,35,.95) 100%
  );
  border: 1px solid rgba(212,183,126,.4); 
  border-radius: var(--radius-large); 
  padding: 24px; 
  backdrop-filter: blur(16px);
  box-shadow: 
    0 12px 24px rgba(0,0,0,.2),
    inset 0 1px 0 rgba(255,255,255,.05),
    0 0 20px rgba(212,183,126,.1);
  position: relative;
}

.player-info-bar::before{
  content: ''; 
  position: absolute; 
  top: 0; left: 30px; right: 30px; height: 2px; 
  background: linear-gradient(90deg, 
    transparent, 
    rgba(212,183,126,.6) 20%, 
    #d4b77e 50%, 
    rgba(212,183,126,.6) 80%, 
    transparent
  );
  opacity: .8;
}

.info-header{ 
  display: flex; 
  justify-content: space-between; 
  align-items: center; 
  margin-bottom: 20px; 
}

.player-name{ 
  font-family: var(--serif); 
  font-size: 28px; 
  font-weight: 800; 
  color: #e6d3aa; 
  text-shadow: 0 2px 10px rgba(212,183,126,.4); 
}

.player-team{ 
  font-size: 14px; 
  color: rgba(248,246,240,.8); 
  font-weight: 600; 
  padding: 8px 18px; 
  background: rgba(212,183,126,.15); 
  border: 1px solid rgba(212,183,126,.4); 
  border-radius: 999px; 
  letter-spacing: .02em;
}

/* 턴 상태 */
.turn-status{ 
  font-size: 18px; 
  font-weight: 700; 
  padding: 12px 24px; 
  border-radius: 999px; 
  border: 1px solid rgba(212,183,126,.3); 
  background: rgba(26,32,44,.9); 
  color: rgba(248,246,240,.7); 
  transition: all .4s ease;
  backdrop-filter: blur(8px);
}

.turn-status.active{ 
  background: linear-gradient(135deg, #e6d3aa, #c9a96e); 
  color: #0a0f1a; 
  border-color: #e6d3aa; 
  box-shadow: 
    0 0 25px rgba(212,183,126,.6), 
    0 0 12px rgba(212,183,126,.4) inset;
  animation: turnGlow 3s ease-in-out infinite; 
  font-weight: 800;
}

@keyframes turnGlow{ 
  0%, 100% {
    box-shadow: 
      0 0 25px rgba(212,183,126,.6), 
      0 0 12px rgba(212,183,126,.4) inset;
  } 
  50% {
    box-shadow: 
      0 0 35px rgba(212,183,126,.8), 
      0 0 18px rgba(212,183,126,.6) inset;
  } 
}

/* 액션 버튼 */
.action-bar{ 
  display: flex; 
  gap: 16px; 
  flex-wrap: wrap; 
  justify-content: center; 
  margin-top: 16px; 
}

.action-btn{
  padding: 16px 24px; 
  font-size: 15px; 
  font-weight: 700; 
  border-radius: var(--radius); 
  border: 2px solid rgba(212,183,126,.3);
  background: linear-gradient(145deg, 
    rgba(42,52,65,.95), 
    rgba(26,32,44,.95)
  ); 
  color: rgba(248,246,240,.9); 
  cursor: pointer; 
  transition: all .3s ease; 
  position: relative; 
  overflow: hidden; 
  min-width: 110px;
  backdrop-filter: blur(8px);
  box-shadow: 0 4px 8px rgba(0,0,0,.1);
}

.action-btn::before{ 
  content: ''; 
  position: absolute; 
  inset: 0; 
  background: linear-gradient(135deg, 
    rgba(212,183,126,.2), 
    transparent 60%, 
    rgba(212,183,126,.1)
  ); 
  opacity: 0; 
  transition: opacity .3s ease; 
}

.action-btn:hover:not(:disabled){ 
  transform: translateY(-4px); 
  border-color: #d4b77e; 
  box-shadow: 0 8px 20px rgba(0,0,0,.2), 0 0 25px rgba(212,183,126,.3); 
  color: #e6d3aa;
}

.action-btn:hover:not(:disabled)::before{ 
  opacity: 1; 
}

.action-btn:disabled{ 
  opacity: .5; 
  cursor: not-allowed; 
  transform: none; 
}

.action-btn.primary{ 
  background: linear-gradient(145deg, #e6d3aa, #c9a96e); 
  color: #0a0f1a; 
  border-color: #d4b77e; 
  font-weight: 800; 
  box-shadow: 0 6px 12px rgba(0,0,0,.15), 0 0 20px rgba(212,183,126,.2);
}

.action-btn.primary:hover:not(:disabled){
  background: linear-gradient(145deg, #f0e4c5, #d4b77e);
  box-shadow: 0 12px 24px rgba(0,0,0,.25), 0 0 30px rgba(212,183,126,.4);
  transform: translateY(-4px) scale(1.03);
}

/* 게임 힌트 */
.game-hint{ 
  text-align: center; 
  color: rgba(184,168,152,.8); 
  font-size: 14px; 
  font-style: italic; 
  margin-top: 16px; 
  padding: 12px; 
  background: rgba(212,183,126,.08); 
  border-radius: var(--radius); 
  border: 1px solid rgba(212,183,126,.15);
  backdrop-filter: blur(8px);
}

.game-hint.active{ 
  color: #e6d3aa; 
  background: rgba(212,183,126,.15); 
  border-color: rgba(212,183,126,.4);
  font-weight: 600;
  font-style: normal;
}

/* 전투 초상화 */
.battle-portrait{
  position: relative; 
  min-height: 380px; 
  display: flex; 
  align-items: flex-end; 
  justify-content: center;
  border: 1px solid rgba(212,183,126,.3); 
  border-radius: var(--radius-xl);
  background: 
    radial-gradient(circle at 30% 20%, rgba(212,183,126,.12), transparent 65%), 
    radial-gradient(circle at 70% 80%, rgba(212,183,126,.08), transparent 55%),
    linear-gradient(180deg, rgba(5,20,38,.98), rgba(7,28,48,.99), rgba(10,33,56,.98));
  overflow: hidden; 
  backdrop-filter: blur(12px);
  box-shadow: 
    0 12px 24px rgba(0,0,0,.2),
    inset 0 2px 0 rgba(255,255,255,.03);
}

.portrait-character{
  position: absolute; 
  bottom: 0; 
  width: min(46%, 340px); 
  aspect-ratio: 3/4;
  background: linear-gradient(135deg, #0f1419, #141a24) center/contain no-repeat;
  border: 2px solid rgba(212,183,126,.3); 
  border-radius: 16px 16px 0 0;
  box-shadow: 0 16px 32px rgba(0,0,0,.3), inset 0 2px 0 rgba(255,255,255,.06); 
  transition: all .5s ease;
  filter: brightness(.92);
}

.portrait-character.left{ left: 10%; }
.portrait-character.right{ right: 10%; }

.portrait-character.active{ 
  transform: translateY(-6px) scale(1.03); 
  border-color: #e6d3aa; 
  filter: brightness(1.15);
  box-shadow:
    0 20px 40px rgba(0,0,0,.4), 
    0 0 0 4px rgba(212,183,126,.6), 
    0 0 30px rgba(212,183,126,.4), 
    inset 0 2px 0 rgba(255,255,255,.12);
  animation: championAura 4.5s ease-in-out infinite;
}

@keyframes championAura{
  0%, 100% {
    box-shadow:
      0 20px 40px rgba(0,0,0,.4), 
      0 0 0 4px rgba(212,183,126,.6), 
      0 0 30px rgba(212,183,126,.4), 
      inset 0 2px 0 rgba(255,255,255,.12);
  }
  50% {
    box-shadow:
      0 20px 40px rgba(0,0,0,.4), 
      0 0 0 5px rgba(212,183,126,.8), 
      0 0 40px rgba(212,183,126,.6), 
      inset 0 2px 0 rgba(255,255,255,.18);
  }
}

.portrait-stats{
  position: absolute; 
  bottom: 20px; left: 20px; right: 20px; 
  display: flex; 
  gap: 20px; 
  flex-wrap: wrap; 
  color: rgba(248,246,240,.9); 
  font-size: 15px; 
  font-weight: 600;
  background: rgba(10,33,56,.97); 
  border: 1px solid rgba(212,183,126,.3); 
  border-radius: 14px; 
  padding: 18px 22px; 
  backdrop-filter: blur(16px); 
  box-shadow: 0 8px 16px rgba(0,0,0,.2);
}

.stat-item{ 
  display: flex; 
  align-items: center; 
  gap: 10px; 
}

.stat-label{ 
  color: rgba(184,168,152,.8); 
  font-size: 13px; 
}

.stat-value{ 
  color: #e6d3aa; 
  font-weight: 800; 
}

/* 팀 패널 */
.team-panel{ 
  display: flex; 
  flex-direction: column; 
  gap: 16px; 
}

.team-header{ 
  text-align: center; 
  font-family: var(--serif); 
  font-weight: 800; 
  font-size: 19px; 
  color: #e6d3aa;
  padding: 16px 20px; 
  background: linear-gradient(135deg, 
    rgba(212,183,126,.18), 
    rgba(212,183,126,.10)
  ); 
  border: 1px solid rgba(212,183,126,.4); 
  border-radius: var(--radius-large); 
  position: relative;
  text-shadow: 0 2px 8px rgba(212,183,126,.4);
  box-shadow: 0 4px 8px rgba(0,0,0,.1);
}

.team-header::before{ 
  content: ''; 
  position: absolute; 
  top: 0; left: 25%; right: 25%; height: 2px; 
  background: linear-gradient(90deg, transparent, #e6d3aa, transparent);
}

/* 유닛 카드 */
.unit{ 
  display: flex; 
  gap: 16px; 
  align-items: center; 
  border: 1px solid rgba(212,183,126,.25); 
  border-radius: var(--radius); 
  padding: 14px; 
  background: rgba(16,21,35,.85); 
  transition: all .3s ease; 
  position: relative;
  box-shadow: 0 4px 8px rgba(0,0,0,.1);
  backdrop-filter: blur(8px);
}

.unit::before{ 
  content: ''; 
  position: absolute; 
  inset: 0; 
  background: linear-gradient(135deg, 
    transparent, 
    rgba(212,183,126,.06), 
    transparent
  ); 
  opacity: 0; 
  transition: opacity .3s ease; 
  border-radius: inherit; 
}

.unit:hover{ 
  border-color: rgba(212,183,126,.5); 
  transform: translateY(-3px); 
  box-shadow: 0 8px 16px rgba(0,0,0,.15), 0 0 20px rgba(212,183,126,.1); 
}

.unit:hover::before{ 
  opacity: 1; 
}

.unit.active{ 
  border-color: #d4b77e; 
  background: rgba(212,183,126,.12); 
  box-shadow:
    0 8px 16px rgba(0,0,0,.15), 
    0 0 0 2px rgba(212,183,126,.4), 
    0 0 20px rgba(212,183,126,.15);
  animation: activeUnitGlow 3.5s ease-in-out infinite; 
}

@keyframes activeUnitGlow{
  0%, 100% {
    box-shadow:
      0 8px 16px rgba(0,0,0,.15), 
      0 0 0 2px rgba(212,183,126,.4), 
      0 0 20px rgba(212,183,126,.15);
  }
  50% {
    box-shadow:
      0 8px 16px rgba(0,0,0,.15), 
      0 0 0 3px rgba(212,183,126,.6), 
      0 0 25px rgba(212,183,126,.25);
  }
}

.unit.dead{ 
  opacity: .6; 
  filter: grayscale(.9); 
  border-style: dashed; 
}

.unit-avatar{ 
  width: 58px; 
  height: 58px; 
  border-radius: var(--radius); 
  background: linear-gradient(135deg, #0f1419, #141a24) center/cover no-repeat; 
  border: 2px solid rgba(212,183,126,.3); 
  position: relative; 
  overflow: hidden;
  box-shadow: 0 4px 8px rgba(0,0,0,.1);
}

.unit-avatar::after{ 
  content: ''; 
  position: absolute; 
  inset: 0; 
  background: linear-gradient(135deg, 
    transparent 25%, 
    rgba(212,183,126,.10) 85%
  ); 
  opacity: .9; 
}

.unit-info{ 
  flex: 1; 
  min-width: 0; 
}

.unit-name{ 
  font-weight: 800; 
  color: rgba(248,246,240,.95); 
  margin-bottom: 8px; 
  font-size: 16px; 
}

.unit-name.dead::after{ 
  content: ' (불능)'; 
  color: rgba(184,168,152,.7); 
  font-weight: 400; 
  font-size: 14px; 
}

.unit-hp{ 
  height: 10px; 
  background: rgba(26,31,42,.95); 
  border-radius: 5px; 
  overflow: hidden; 
  margin: 8px 0; 
  position: relative; 
  box-shadow: inset 0 2px 4px rgba(0,0,0,.4); 
}

.unit-hp::after{ 
  content: ''; 
  position: absolute; 
  inset: 0; 
  background: linear-gradient(90deg, rgba(255,255,255,.2), transparent 45%); 
  pointer-events: none; 
}

.unit-hp-bar{ 
  display: block; 
  height: 100%; 
  background: linear-gradient(90deg, #c9a96e, #e6d3aa); 
  transition: width .7s ease; 
  position: relative; 
  box-shadow: 0 0 10px rgba(212,183,126,.5); 
}

.unit-stats{ 
  font-size: 12px; 
  color: rgba(184,168,152,.8); 
  line-height: 1.4; 
}

/* 채팅 패널 */
.chat-panel{ 
  display: flex; 
  flex-direction: column; 
  height: 100%;
  min-height: 640px;
}

.chat-header{ 
  display: flex; 
  gap: 14px; 
  align-items: center; 
  margin-bottom: 16px; 
}

.chat-channel{ 
  min-width: 100px; 
  font-size: 14px; 
  padding: 12px 16px;
  font-weight: 600;
}

.chat-input{ 
  flex: 1; 
  font-size: 14px; 
  padding: 12px 16px;
  font-weight: 500;
}

.chat-send{ 
  padding: 12px 20px; 
  font-size: 14px;
  font-weight: 700;
}

.chat-messages{ 
  flex: 1; 
  background: linear-gradient(145deg, 
    rgba(5,15,28,.98) 0%, 
    rgba(8,20,35,.96) 50%, 
    rgba(5,15,28,.98) 100%
  );
  border: 1px solid rgba(212,183,126,.25); 
  border-radius: var(--radius); 
  padding: 18px; 
  overflow-y: auto; 
  font-size: 13px; 
  line-height: 1.6; 
  min-height: 260px; 
  backdrop-filter: blur(8px); 
  box-shadow:
    inset 0 4px 12px rgba(0,0,0,.5), 
    inset 0 1px 0 rgba(255,255,255,.03),
    0 4px 8px rgba(0,0,0,.1);
}

.chat-message{ 
  display: flex; 
  gap: 12px; 
  align-items: baseline; 
  margin-bottom: 10px; 
  padding: 8px 12px; 
  border-radius: var(--radius-small); 
  transition: background .2s ease;
  border-bottom: 1px solid rgba(212,183,126,.05); 
}

.chat-message:hover{ 
  background: rgba(212,183,126,.08); 
}

.chat-time{ 
  font-size: 11px; 
  color: rgba(184,168,152,.7); 
  min-width: 52px; 
  font-weight: 600; 
}

.chat-content{ 
  flex: 1; 
  color: rgba(224,213,196,.9); 
}

.chat-message.system .chat-content{ 
  color: #e6d3aa; 
  font-weight: 600; 
}

.chat-message.team .chat-content{ 
  color: #5DADE2; 
}

.chat-message.cheer .chat-content{ 
  color: #58D68D;
  font-weight: 600;
}

/* 전투 로그 */
.battle-log{ 
  background: linear-gradient(145deg, 
    rgba(5,15,28,.98) 0%, 
    rgba(8,20,35,.96) 50%, 
    rgba(5,15,28,.98) 100%
  );
  border: 1px solid rgba(212,183,126,.25); 
  border-radius: var(--radius); 
  padding: 18px; 
  height: 220px; 
  overflow-y: auto; 
  font-size: 13px; 
  line-height: 1.6; 
  backdrop-filter: blur(8px); 
  box-shadow:
    inset 0 4px 12px rgba(0,0,0,.5), 
    inset 0 1px 0 rgba(255,255,255,.03),
    0 4px 8px rgba(0,0,0,.1);
}

.log-entry{ 
  display: flex; 
  gap: 12px; 
  align-items: baseline; 
  margin-bottom: 10px; 
  padding: 8px 12px; 
  border-radius: var(--radius-small); 
  transition: background .2s ease; 
}

.log-entry:hover{ 
  background: rgba(212,183,126,.08); 
}

.log-entry .time{ 
  font-size: 11px; 
  color: rgba(184,168,152,.7); 
  min-width: 52px; 
  font-weight: 600; 
}

.log-entry .content{ 
  flex: 1; 
  color: rgba(224,213,196,.9); 
}

.log-entry.action .content{ 
  color: rgba(248,246,240,.95); 
  font-weight: 600; 
}

.log-entry.system .content{ 
  color: #e6d3aa; 
  font-weight: 600; 
}

/* 타겟 선택 오버레이 */
.target-overlay{ 
  position: fixed; 
  inset: 0; 
  display: none; 
  align-items: center; 
  justify-content: center; 
  background: rgba(0,0,0,.85); 
  z-index: 1000; 
  backdrop-filter: blur(12px); 
}

.target-panel{ 
  width: min(700px, 92vw); 
  background: linear-gradient(145deg, 
    rgba(16,21,35,.98) 0%, 
    rgba(26,32,44,.95) 50%, 
    rgba(16,21,35,.98) 100%
  ); 
  border: 2px solid #d4b77e; 
  border-radius: var(--radius-xl); 
  padding: 28px; 
  backdrop-filter: blur(20px); 
  box-shadow: 
    0 25px 50px rgba(0,0,0,.4), 
    0 0 40px rgba(212,183,126,.2); 
  animation: targetAppear .5s ease; 
}

@keyframes targetAppear{ 
  from {
    opacity: 0; 
    transform: scale(.85) translateY(-40px);
  } 
  to {
    opacity: 1; 
    transform: scale(1) translateY(0);
  } 
}

.target-title{ 
  font-family: var(--serif); 
  font-size: 26px; 
  font-weight: 800; 
  color: #e6d3aa; 
  text-align: center; 
  margin-bottom: 24px;
  text-shadow: 0 2px 10px rgba(212,183,126,.4);
}

.target-list{ 
  display: grid; 
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); 
  gap: 16px; 
  margin-bottom: 24px; 
}

.target-card{ 
  border: 1px solid rgba(212,183,126,.3); 
  border-radius: var(--radius); 
  padding: 20px; 
  background: rgba(42,52,65,.8); 
  cursor: pointer; 
  transition: all .3s ease; 
  text-align: center;
  backdrop-filter: blur(8px);
  box-shadow: 0 4px 8px rgba(0,0,0,.1);
}

.target-card:hover:not(.disabled){ 
  border-color: #d4b77e; 
  background: rgba(212,183,126,.15); 
  transform: translateY(-3px); 
  box-shadow: 0 8px 16px rgba(0,0,0,.2), 0 0 20px rgba(212,183,126,.15); 
}

.target-card.disabled{ 
  opacity: .5; 
  cursor: not-allowed; 
}

.target-name{ 
  font-weight: 700; 
  margin-bottom: 8px;
  color: rgba(248,246,240,.95);
  font-size: 16px;
}

.target-hp{ 
  font-size: 13px; 
  color: rgba(184,168,152,.8); 
}

.target-actions{ 
  display: flex; 
  justify-content: center; 
  gap: 16px; 
}

/* 단축키 힌트 */
.hotkey-hint{ 
  font-size: 11px; 
  color: rgba(184,168,152,.6); 
  margin-left: 8px; 
  opacity: .8; 
}

/* 스크롤바 커스터마이징 */
.chat-messages::-webkit-scrollbar, 
.battle-log::-webkit-scrollbar{ 
  width: 10px; 
}

.chat-messages::-webkit-scrollbar-track, 
.battle-log::-webkit-scrollbar-track{ 
  background: rgba(5,15,28,.9); 
  border-radius: 5px; 
}

.chat-messages::-webkit-scrollbar-thumb, 
.battle-log::-webkit-scrollbar-thumb{ 
  background: linear-gradient(to bottom, #d4b77e, #c9a96e); 
  border-radius: 5px; 
  border: 1px solid rgba(0,0,0,.3); 
}

.chat-messages::-webkit-scrollbar-thumb:hover, 
.battle-log::-webkit-scrollbar-thumb:hover{ 
  background: linear-gradient(to bottom, #e6d3aa, #d4b77e); 
}

/* 특수 효과 */
.sparkle-effect{
  position: relative;
  overflow: hidden;
}

.sparkle-effect::before{
  content: '✧';
  position: absolute;
  top: 14px;
  right: 18px;
  color: #d4b77e;
  font-size: 12px;
  opacity: .6;
  animation: sparkleRotate 4s ease-in-out infinite;
}

@keyframes sparkleRotate{
  0%, 100% { 
    opacity: .3; 
    transform: scale(.8) rotate(0deg); 
  }
  50% { 
    opacity: 1; 
    transform: scale(1.5) rotate(180deg); 
  }
}

.enhance-hover{
  position: relative;
  overflow: hidden;
}

.enhance-hover::after{
  content: '';
  position: absolute;
  top: 0; left: -100%; right: 100%; bottom: 0;
  background: linear-gradient(90deg,
    transparent,
    rgba(212,183,126,.12),
    transparent
  );
  transition: all .7s ease;
}

.enhance-hover:hover::after{
  left: 100%; right: -100%;
}

/* 연결 상태 표시 */
.connection-status{
  position: fixed;
  top: 24px;
  left: 24px;
  z-index: 1000;
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 18px;
  background: rgba(16,21,35,.95);
  border: 1px solid rgba(212,183,126,.3);
  border-radius: 999px;
  font-size: 13px;
  font-weight: 600;
  backdrop-filter: blur(12px);
  box-shadow: 0 4px 12px rgba(0,0,0,.15);
}

.connection-dot{
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #e74c3c;
  animation: connectionPulse 2.5s ease-in-out infinite;
}

.connection-dot.connected{
  background: #27ae60;
}

.connection-dot.connecting{
  background: #f39c12;
}

@keyframes connectionPulse{
  0%, 100% { opacity: .7; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.3); }
}

/* 피드백 애니메이션 */
.feedback-success{
  background: linear-gradient(135deg, #27ae60, #219a52) !important;
  color: white !important;
  border-color: #27ae60 !important;
  animation: feedbackPulse .9s ease;
}

.feedback-error{
  background: linear-gradient(135deg, #e74c3c, #c0392b) !important;
  color: white !important;
  border-color: #e74c3c !important;
  animation: feedbackShake .7s ease-in-out;
}

@keyframes feedbackPulse{
  0% { transform: scale(1); }
  50% { transform: scale(1.06); }
  100% { transform: scale(1); }
}

@keyframes feedbackShake{
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

/* 로딩 효과 */
.loading{
  opacity: .7;
  pointer-events: none;
  position: relative;
}

.loading::after{
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, 
    transparent, 
    rgba(212,183,126,.15), 
    transparent
  );
  animation: shimmer 1.8s infinite;
  border-radius: inherit;
}

@keyframes shimmer{
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

/* 반응형 디자인 */
@media (max-width: 768px){
  .player-header{
    padding: 32px 18px 16px;
  }
  
  .player-stage{
    padding: 16px 20px;
    gap: 16px;
  }
  
  .player-brand{
    font-size: 34px;
  }
  
  .player-brand::after{
    top: -8px;
    right: -56px;
    font-size: 12px;
    padding: 5px 12px;
  }
  
  .action-bar{ 
    justify-content: stretch; 
  }
  
  .action-btn{ 
    flex: 1; 
    min-width: auto; 
    padding: 14px 20px;
  }
  
  .portrait-stats{ 
    flex-direction: column; 
    gap: 12px; 
  }
  
  .stat-item{ 
    justify-content: space-between; 
  }
  
  .target-list{ 
    grid-template-columns: 1fr; 
  }
  
  .chat-header{
    flex-direction: column;
    gap: 12px;
  }
  
  .chat-channel{
    width: 100%;
    min-width: auto;
  }
  
  .connection-status{
    top: 12px;
    left: 12px;
    padding: 8px 14px;
    font-size: 12px;
  }
}

@media (max-width: 480px){
  .player-header{
    padding: 28px 14px 12px;
  }
  
  .player-stage{
    padding: 14px 18px;
  }
  
  .player-brand{
    font-size: 28px;
  }
  
  .auth-section{
    padding: 24px;
  }
  
  .action-btn{
    padding: 12px 18px;
    font-size: 14px;
  }
  
  .portrait-character{
    width: min(52%, 300px);
  }
}

/* 접근성 개선 */
@media (prefers-reduced-motion: reduce){
  .player-header::before,
  .player-brand,
  .player-brand::before,
  .turnGlow,
  .championAura,
  .activeUnitGlow,
  .sparkleRotate,
  .shimmer,
  .connectionPulse{
    animation: none;
  }
  
  .unit:hover,
  .action-btn:hover:not(:disabled),
  .target-card:hover:not(.disabled){
    transform: none;
  }
}

/* 숨김 유틸리티 */
.hide{
  display: none !important;
}
</style>
</head>
<body>
<!-- 연결 상태 표시 -->
<div class="connection-status" id="connectionStatus">
  <div class="connection-dot" id="connectionDot"></div>
  <span id="connectionText">연결 중...</span>
</div>

<header class="player-header">
  <div class="wrap">
    <div class="player-brand sparkle-effect">Pyxis</div>
  </div>
</header>

<main class="wrap player-stage">
  <!-- 좌측: 팀 정보 -->
  <aside class="team-panel" id="leftTeam">
    <div class="team-header enhance-hover">아군</div>
    <div id="allyUnits"></div>
  </aside>

  <!-- 중앙: 메인 -->
  <section class="center-section">
    <!-- 인증 폼 -->
    <div class="card auth-section sparkle-effect" id="authSection" style="display:none">
      <div class="auth-title">전투 입장</div>
      <div class="auth-form">
        <div class="field">
          <label for="authBattleId">전투 ID</label>
          <input id="authBattleId" class="input enhance-hover" placeholder="battle_xxxxx" maxlength="50">
        </div>
        <div class="auth-row">
          <div class="field">
            <label for="authToken">플레이어 OTP</label>
            <input id="authToken" class="input enhance-hover" placeholder="인증 토큰" maxlength="50">
          </div>
          <div class="field">
            <label for="authName">플레이어 이름</label>
            <input id="authName" class="input enhance-hover" placeholder="캐릭터 이름" maxlength="20">
          </div>
        </div>
        <button id="authJoinBtn" class="btn btn-gold enhance-hover">전투 참가</button>
      </div>
    </div>

    <!-- 정보 바 -->
    <div class="player-info-bar card sparkle-effect">
      <div class="info-header">
        <div>
          <div class="player-name" id="playerName">-</div>
          <div class="player-team" id="playerTeam">-</div>
        </div>
        <div class="turn-status" id="turnStatus">대기중</div>
      </div>
      <div class="action-bar" id="actionBar">
        <button class="action-btn primary enhance-hover" id="btnAttack">공격<span class="hotkey-hint">[1]</span></button>
        <button class="action-btn enhance-hover" id="btnDefend">방어<span class="hotkey-hint">[2]</span></button>
        <button class="action-btn enhance-hover" id="btnDodge">회피<span class="hotkey-hint">[3]</span></button>
        <button class="action-btn enhance-hover" id="btnUseItem">아이템<span class="hotkey-hint">[4]</span></button>
        <button class="action-btn enhance-hover" id="btnPass">패스<span class="hotkey-hint">[5]</span></button>
      </div>
      <div class="game-hint" id="gameHint">내 턴에만 행동할 수 있습니다</div>
    </div>

    <!-- 초상화/스탯 -->
    <div class="card battle-portrait sparkle-effect">
      <div class="portrait-character" id="portraitChar" style="display:none"></div>
      <div class="portrait-stats" id="portraitStats" style="display:none"></div>
    </div>

    <!-- 전투 로그 -->
    <div class="card sparkle-effect">
      <div class="section-header">
        <div class="section-title" style="font-size:16px;">전투 로그</div>
      </div>
      <div id="battleLog" class="battle-log" aria-label="전투 로그"></div>
    </div>
  </section>

  <!-- 우측: 채팅 -->
  <aside class="card chat-panel sparkle-effect">
    <div class="section-header">
      <div class="section-title" style="font-size:16px;">실시간 채팅</div>
    </div>
    <div class="chat-header">
      <select id="chatChannel" class="select chat-channel enhance-hover">
        <option value="all">전체</option>
        <option value="team">팀</option>
      </select>
      <input id="chatInput" class="input chat-input enhance-hover" placeholder="메시지 입력 (/t 팀 채팅)" maxlength="200">
      <button id="chatSend" class="btn chat-send enhance-hover">전송</button>
    </div>
    <div id="chatMessages" class="chat-messages" aria-label="채팅 메시지"></div>
  </aside>
</main>

<!-- 타겟 선택 -->
<div class="target-overlay" id="targetOverlay" role="dialog" aria-modal="true">
  <div class="target-panel sparkle-effect">
    <div class="target-title" id="targetTitle">대상 선택</div>
    <div class="target-list" id="targetList"></div>
    <div class="target-actions">
      <button class="btn enhance-hover" id="cancelTarget">취소</button>
    </div>
  </div>
</div>

<script>
(function(){
  'use strict';
  const $ = id => document.getElementById(id);

  // DOM 요소
  const connectionStatus = $('connectionStatus');
  const connectionDot = $('connectionDot');
  const connectionText = $('connectionText');

  // 인증 UI
  const authSection = $('authSection');
  const authBattleId = $('authBattleId');
  const authToken = $('authToken');
  const authName = $('authName');
  const authJoinBtn = $('authJoinBtn');

  // 게임 UI
  const allyUnits = $('allyUnits');
  const playerNameEl = $('playerName');
  const playerTeamEl = $('playerTeam');
  const turnStatus = $('turnStatus');
  const gameHint = $('gameHint');

  // 액션 버튼
  const btnAttack = $('btnAttack');
  const btnDefend = $('btnDefend');
  const btnDodge = $('btnDodge');
  const btnUseItem = $('btnUseItem');
  const btnPass = $('btnPass');

  // 초상화/로그/채팅
  const portraitChar = $('portraitChar');
  const portraitStats = $('portraitStats');
  const battleLog = $('battleLog');
  const chatChannel = $('chatChannel');
  const chatInput = $('chatInput');
  const chatSend = $('chatSend');
  const chatMessages = $('chatMessages');

  // 타겟 선택
  const targetOverlay = $('targetOverlay');
  const targetTitle = $('targetTitle');
  const targetList = $('targetList');
  const cancelTarget = $('cancelTarget');

  // 상태 관리
  let socket = null;
  let state = null;
  let myPid = null;
  let me = null;
  let joined = false;
  let currentBattleId = null;
  let reconnectAttempts = 0;
  let reconnectTimer = null;
  const MAX_RECONNECT_ATTEMPTS = 5;
  const RECONNECT_DELAY = 1000;

  // 소켓 초기화
  const initSocket = () => {
    if (socket) {
      socket.disconnect();
    }
    
    socket = io({
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,
      reconnectionDelay: RECONNECT_DELAY,
      reconnectionDelayMax: 10000,
      maxReconnectionAttempts: MAX_RECONNECT_ATTEMPTS,
      timeout: 20000,
      forceNew: true
    });

    setupSocketEvents();
    return socket;
  };

  // 연결 상태 업데이트
  const updateConnectionStatus = (status, text) => {
    connectionDot.className = `connection-dot ${status}`;
    connectionText.textContent = text;
    
    switch(status) {
      case 'connected':
        connectionDot.style.background = '#27ae60';
        break;
      case 'connecting':
        connectionDot.style.background = '#f39c12';
        break;
      case 'disconnected':
      default:
        connectionDot.style.background = '#e74c3c';
        break;
    }
  };

  // 알림 시스템
  const showNotification = (message, type = 'info') => {
    console.log(`[${type.toUpperCase()}] ${message}`);
    
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed; top: 24px; right: 24px; z-index: 10000;
      padding: 14px 24px; border-radius: 10px; color: white; font-weight: 600;
      background: ${type === 'error' ? 'linear-gradient(135deg, #e74c3c, #c0392b)' : 
                   type === 'success' ? 'linear-gradient(135deg, #27ae60, #219a52)' : 
                   'linear-gradient(135deg, #3498db, #2980b9)'};
      box-shadow: 0 6px 16px rgba(0,0,0,0.3);
      transform: translateX(100%); transition: transform 0.4s ease;
      max-width: 320px; word-wrap: break-word; font-size: 14px;
      backdrop-filter: blur(10px);
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => toast.style.transform = 'translateX(0)', 100);
    setTimeout(() => {
      if (document.body.contains(toast)) {
        toast.style.transform = 'translateX(100%)';
        setTimeout(() => {
          if (document.body.contains(toast)) {
            document.body.removeChild(toast);
          }
        }, 400);
      }
    }, 3500);
  };

  // 유틸리티 함수
  const fmtTime = t => {
    try { 
      return new Date(t).toLocaleTimeString([], {hour12: false}); 
    } catch { 
      return '--:--:--'; 
    }
  };
  
  const teamLabel = key => (key === 'A' || key === 'team1') ? '불사조 기사단' : '죽음을 먹는 자들';
  const hpPct = p => !p ? 0 : Math.max(0, Math.min(100, Math.round((p.hp / (p.maxHp || 100)) * 100)));
  const currActor = () => state?.turn?.pending?.[0] || state?.turn?.actor || null;
  const isMyTurn = () => (currActor() === myPid) && (me?.alive !== false);

  // 로그 및 채팅 함수
  const log = (txt, type = 'info') => {
    const row = document.createElement('div');
    row.className = `log-entry ${type}`;
    
    const t = document.createElement('span');
    t.className = 'time';
    t.textContent = fmtTime(Date.now());
    
    const c = document.createElement('span');
    c.className = 'content';
    c.textContent = txt;
    
    row.appendChild(t);
    row.appendChild(c);
    battleLog.appendChild(row);
    battleLog.scrollTop = battleLog.scrollHeight;

    // 최대 로그 개수 제한
    while (battleLog.children.length > 100) {
      battleLog.removeChild(battleLog.firstChild);
    }
  };
  
  const addChat = (m) => {
    const wrap = document.createElement('div');
    wrap.className = `chat-message ${m.type || (m.scope === 'team' ? 'team' : '')}`;
    
    const t = document.createElement('span');
    t.className = 'chat-time';
    t.textContent = fmtTime(m.ts || Date.now());
    
    const c = document.createElement('span');
    c.className = 'chat-content';
    
    if (m.type === 'system') {
      c.textContent = `[시스템] ${m.text}`;
    } else if (m.type === 'cheer') {
      c.textContent = `[응원] ${m.from?.nickname || m.from || '익명'}: ${m.text}`;
    } else {
      const scope = (m.scope === 'team' || m.channel === 'team') ? '[팀] ' : '[전체] ';
      const nick = m.from?.nickname || m.from || m.nickname || '익명';
      c.textContent = `${scope}${nick}: ${m.text}`;
    }
    
    wrap.appendChild(t);
    wrap.appendChild(c);
    chatMessages.appendChild(wrap);
    chatMessages.scrollTop = chatMessages.scrollHeight;

    // 최대 채팅 개수 제한
    while (chatMessages.children.length > 100) {
      chatMessages.removeChild(chatMessages.firstChild);
    }
  };

  // 소켓 이벤트 설정
  const setupSocketEvents = () => {
    if (!socket) return;

    // 연결 이벤트
    socket.on('connect', () => {
      updateConnectionStatus('connected', '연결됨');
      reconnectAttempts = 0;
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      showNotification('서버에 연결되었습니다', 'success');
      console.log('[Socket] Connected to server');
    });

    socket.on('disconnect', (reason) => {
      updateConnectionStatus('disconnected', '연결 끊김');
      console.log(`[Socket] Disconnected: ${reason}`);
      
      if (joined) {
        if (reason === 'io server disconnect') {
          showNotification('서버와의 연결이 종료되었습니다', 'error');
        } else {
          showNotification('연결이 끊어졌습니다. 재연결 시도 중...', 'error');
        }
      }
    });

    socket.on('connect_error', (error) => {
      updateConnectionStatus('disconnected', '연결 실패');
      console.error('[Socket] Connection error:', error);
      
      if (joined) {
        showNotification(`연결 오류: ${error.message || '알 수 없는 오류'}`, 'error');
      }
    });

    socket.on('reconnect', (attemptNumber) => {
      updateConnectionStatus('connected', '재연결됨');
      showNotification(`서버에 재연결되었습니다 (시도 ${attemptNumber}회)`, 'success');
      console.log(`[Socket] Reconnected after ${attemptNumber} attempts`);
      
      // 재연결 후 상태 복구
      if (joined && currentBattleId) {
        requestStateUpdate();
      }
    });

    socket.on('reconnect_attempt', (attemptNumber) => {
      updateConnectionStatus('connecting', `재연결 중... (${attemptNumber}회)`);
      console.log(`[Socket] Reconnection attempt ${attemptNumber}`);
    });

    socket.on('reconnect_failed', () => {
      updateConnectionStatus('disconnected', '재연결 실패');
      showNotification('서버 재연결에 실패했습니다', 'error');
      console.error('[Socket] Reconnection failed');
    });

    // 게임 이벤트
    socket.on('chat:new', (message) => {
      try {
        addChat(message);
      } catch (error) {
        console.error('[Socket] Error handling chat message:', error);
      }
    });

    socket.on('chat', (message) => {
      try {
        addChat(message);
      } catch (error) {
        console.error('[Socket] Error handling chat:', error);
      }
    });

    socket.on('log:new', (ev) => {
      try {
        if (ev?.text) {
          log(ev.text, 'system');
        }
      } catch (error) {
        console.error('[Socket] Error handling log:', error);
      }
    });
    
    socket.on('phase:change', (p) => {
      try {
        const teamName = (p.phase === 'A' || p.phase === 'team1') ? '불사조 기사단' : '죽음을 먹는 자들';
        log(`▶︎ 턴 전환: ${teamName} (라운드 ${p.round})`, 'system');
        
        if (state) {
          state.turn = { ...state.turn, actor: null, pending: [], phase: p.phase, round: p.round };
          state.phase = p.phase;
          state.round = p.round;
        }
        
        render();
      } catch (error) {
        console.error('[Socket] Error handling phase change:', error);
      }
    });
    
    socket.on('battle:end', (r) => {
      try {
        const winnerText = r.winner === 'draw' ? '무승부' : 
                          (r.winner === 'A' || r.winner === 'team1' ? '불사조 기사단' : '죽음을 먹는 자들');
        log(`◆ 전투 종료: ${winnerText} / A=${r.scoreA || 0} / B=${r.scoreB || 0}`, 'system');
        showNotification('전투가 종료되었습니다', 'info');
      } catch (error) {
        console.error('[Socket] Error handling battle end:', error);
      }
    });

    socket.on('state:update', (s) => {
      try {
        state = s;
        me = myPid && s?.players ? s.players[myPid] : me;
        render();
      } catch (error) {
        console.error('[Socket] Error handling state update:', error);
      }
    });
    
    socket.on('state', (s) => {
      try {
        state = s;
        me = myPid && s?.players ? s.players[myPid] : me;
        render();
      } catch (error) {
        console.error('[Socket] Error handling state:', error);
      }
    });

    // 인증 응답
    socket.on('authSuccess', (response) => {
      try {
        joined = true;
        state = response.state || response.battle;
        myPid = response.selfPid || response.playerId;
        me = myPid && state?.players ? state.players[myPid] : null;
        
        authSection.style.display = 'none';
        render();
        
        authJoinBtn.classList.add('feedback-success');
        log('전투에 성공적으로 참가했습니다!', 'system');
        showNotification('전투 입장 완료!', 'success');
        
        setTimeout(() => {
          authJoinBtn.textContent = '전투 참가';
          authJoinBtn.classList.remove('feedback-success');
        }, 2000);
      } catch (error) {
        console.error('[Socket] Error handling auth success:', error);
        showNotification('인증 처리 중 오류가 발생했습니다', 'error');
      }
    });

    socket.on('authError', (message) => {
      authJoinBtn.classList.add('feedback-error');
      setTimeout(() => {
        authJoinBtn.textContent = '전투 참가';
        authJoinBtn.classList.remove('feedback-error');
      }, 2000);
      
      showNotification(`인증 실패: ${message || '알 수 없는 오류'}`, 'error');
    });

    // 액션 응답
    socket.on('actionSuccess', (result) => {
      if (result?.message) {
        showNotification(result.message, 'success');
      }
    });

    socket.on('actionError', (message) => {
      showNotification(`행동 실패: ${message || '알 수 없는 오류'}`, 'error');
    });

    // 채팅 오류
    socket.on('chatError', (error) => {
      showNotification(`채팅 오류: ${error}`, 'error');
    });

    // 오류 처리
    socket.on('error', (error) => {
      console.error('[Socket] Generic error:', error);
      showNotification('소켓 오류가 발생했습니다', 'error');
    });
  };

  // 상태 업데이트 요청
  const requestStateUpdate = () => {
    if (socket && socket.connected && currentBattleId) {
      socket.emit('requestState', { battleId: currentBattleId });
    }
  };

  // 인증 함수 (다중 시도)
  const doJoin = (battleId, token, name) => {
    if (!socket || !socket.connected) {
      showNotification('서버에 연결되어 있지 않습니다', 'error');
      return;
    }

    currentBattleId = battleId;
    authJoinBtn.classList.add('loading');
    authJoinBtn.textContent = '접속 중...';
    
    // 타임아웃 설정
    const authTimeout = setTimeout(() => {
      authJoinBtn.classList.remove('loading');
      authJoinBtn.textContent = '전투 참가';
      authJoinBtn.classList.add('feedback-error');
      setTimeout(() => authJoinBtn.classList.remove('feedback-error'), 1000);
      showNotification('인증 요청 시간이 초과되었습니다', 'error');
    }, 10000);

    // 성공/실패 콜백
    const handleAuthResult = (success, message) => {
      clearTimeout(authTimeout);
      authJoinBtn.classList.remove('loading');
      
      if (!success) {
        authJoinBtn.classList.add('feedback-error');
        setTimeout(() => {
          authJoinBtn.textContent = '전투 참가';
          authJoinBtn.classList.remove('feedback-error');
        }, 2000);
        showNotification(message || '인증에 실패했습니다', 'error');
      }
    };

    // 1) 최신 스펙: join 이벤트
    socket.timeout(8000).emit('join', { 
      role: 'player', 
      battleId, 
      token, 
      name 
    }, (error, ack) => {
      if (error) {
        console.log('[Auth] Join timeout, trying alternative methods');
        // 2) 중간 스펙: playerAuth 이벤트
        socket.timeout(8000).emit('playerAuth', { 
          battleId, 
          playerId: name, 
          otp: token 
        }, (error2, ack2) => {
          if (error2) {
            console.log('[Auth] PlayerAuth timeout, trying legacy');
            // 3) 레거시 스펙: auth 이벤트 (응답 없이 이벤트 대기)
            socket.emit('auth', { 
              role: 'player', 
              battle: battleId, 
              token, 
              name 
            });
          } else if (ack2 && !ack2.ok) {
            handleAuthResult(false, ack2.message || ack2.error);
          }
        });
      } else if (ack && !ack.ok) {
        handleAuthResult(false, ack.msg || ack.message);
      }
    });
  };

  // 전투원 카드 렌더링
  const unitCard = (p) => {
    const el = document.createElement('div');
    el.className = `unit enhance-hover ${currActor() === p.id ? 'active' : ''} ${p.alive === false ? 'dead' : ''}`;
    el.dataset.playerId = p.id;
    
    const av = document.createElement('div');
    av.className = 'unit-avatar';
    if (p.avatar) av.style.backgroundImage = `url(${p.avatar})`;
    
    const info = document.createElement('div');
    info.className = 'unit-info';
    
    const name = document.createElement('div');
    name.className = `unit-name ${p.alive === false ? 'dead' : ''}`;
    name.textContent = p.name;
    
    const hp = document.createElement('div');
    hp.className = 'unit-hp';
    const bar = document.createElement('span');
    bar.className = 'unit-hp-bar';
    bar.style.width = `${hpPct(p)}%`;
    hp.appendChild(bar);
    
    const st = document.createElement('div');
    st.className = 'unit-stats';
    const s = p.stats || { attack: p.atk, defense: p.def, agility: p.agi, luck: p.luk };
    st.textContent = `공격 ${s.attack ?? p.atk} · 방어 ${s.defense ?? p.def} · 민첩 ${s.agility ?? p.agi} · 행운 ${s.luck ?? p.luk}`;
    
    info.appendChild(name);
    info.appendChild(hp);
    info.appendChild(st);
    el.appendChild(av);
    el.appendChild(info);
    return el;
  };

  // 렌더링 함수들
  const renderTeam = () => {
    if (!state?.players || !me) return;
    
    allyUnits.innerHTML = '';
    const allies = Object.values(state.players).filter(x => {
      const tA = (x.team === 'A' || x.team === 'team1');
      const myT = (me.team === 'A' || me.team === 'team1');
      return tA === myT;
    });
    
    allies.forEach(p => allyUnits.appendChild(unitCard(p)));
  };

  const renderInfo = () => {
    if (!me) return;
    
    playerNameEl.textContent = me.name || '-';
    playerTeamEl.textContent = teamLabel(me.team);
    
    const mine = isMyTurn();
    turnStatus.textContent = mine ? '내 차례!' : '대기중';
    turnStatus.classList.toggle('active', mine);
    
    // 행동 버튼 활성화/비활성화
    [btnAttack, btnDefend, btnDodge, btnUseItem, btnPass].forEach(b => {
      b.disabled = !mine;
    });
    
    if (mine) {
      gameHint.textContent = '행동을 선택하세요!';
      gameHint.classList.add('active');
    } else {
      gameHint.textContent = '내 턴을 기다리는 중...';
      gameHint.classList.remove('active');
    }
  };

  const renderPortrait = () => {
    const aId = currActor();
    const p = aId && state?.players?.[aId];
    
    if (p) {
      portraitChar.style.display = 'block';
      portraitChar.style.backgroundImage = p.avatar ? `url(${p.avatar})` : '';
      portraitChar.classList.remove('left', 'right');
      
      const isEnemy = (p.team === 'B' || p.team === 'team2');
      portraitChar.classList.add(isEnemy ? 'right' : 'left');
      portraitChar.classList.toggle('active', aId === myPid);

      const s = p.stats || { attack: p.atk, defense: p.def, agility: p.agi, luck: p.luk };
      portraitStats.style.display = 'flex';
      portraitStats.innerHTML = `
        <div class="stat-item"><span class="stat-label">이름:</span><span class="stat-value">${p.name}</span></div>
        <div class="stat-item"><span class="stat-label">팀:</span><span class="stat-value">${teamLabel(p.team)}</span></div>
        <div class="stat-item"><span class="stat-label">HP:</span><span class="stat-value">${p.hp}/${p.maxHp || 100}</span></div>
        <div class="stat-item"><span class="stat-label">공격:</span><span class="stat-value">${s.attack ?? p.atk}</span></div>
        <div class="stat-item"><span class="stat-label">방어:</span><span class="stat-value">${s.defense ?? p.def}</span></div>
        <div class="stat-item"><span class="stat-label">민첩:</span><span class="stat-value">${s.agility ?? p.agi}</span></div>
        <div class="stat-item"><span class="stat-label">행운:</span><span class="stat-value">${s.luck ?? p.luk}</span></div>
      `;
    } else {
      portraitChar.style.display = 'none';
      portraitStats.style.display = 'none';
    }
  };

  const renderBattleLog = () => {
    if (!state?.chat) return;
    
    battleLog.innerHTML = '';
    state.chat.slice(-50).forEach(e => {
      if (e.type === 'system' || e.type === 'action') {
        log(e.text, e.type);
      }
    });
  };

  const render = () => {
    try {
      if (!state) return;
      
      me = myPid && state.players ? state.players[myPid] : me;
      renderInfo();
      renderPortrait();
      renderTeam();
      renderBattleLog();
    } catch (error) {
      console.error('[Render] Error during render:', error);
    }
  };

  // 타겟 선택 UI
  const showTargets = (title, targets, cb) => {
    targetTitle.textContent = title;
    targetList.innerHTML = '';
    
    targets.forEach(t => {
      const card = document.createElement('div');
      card.className = `target-card enhance-hover ${t.alive === false ? 'disabled' : ''}`;
      
      const n = document.createElement('div');
      n.className = 'target-name';
      n.textContent = t.name;
      
      const h = document.createElement('div');
      h.className = 'target-hp';
      h.textContent = `HP ${t.hp}/${t.maxHp || 100}`;
      
      card.appendChild(n);
      card.appendChild(h);
      
      if (t.alive !== false) {
        card.onclick = () => {
          hideTargets();
          cb(t);
        };
      }
      
      targetList.appendChild(card);
    });
    
    targetOverlay.style.display = 'flex';
  };
  
  const hideTargets = () => {
    targetOverlay.style.display = 'none';
  };

  // 액션 전송 (다중 폴백)
  const sendAction = (type, payload = {}) => {
    if (!socket || !socket.connected) {
      showNotification('서버에 연결되어 있지 않습니다', 'error');
      return;
    }

    const msg = { type, ...payload };
    console.log('[Action] Sending:', msg);
    
    // 1) 최신 스펙: action:player
    socket.timeout(5000).emit('action:player', msg, (error, ack) => {
      if (error || (ack && ack.ok === false)) {
        console.log('[Action] Primary method failed, trying alternative');
        
        // 2) 중간 스펙: player:action
        socket.timeout(5000).emit('player:action', msg, (error2, ack2) => {
          if (error2 || (ack2 && ack2.ok === false)) {
            console.log('[Action] Secondary method failed, trying legacy');
            
            // 3) 레거시 스펙: playerAction
            socket.emit('playerAction', {
              battleId: currentBattleId,
              playerId: myPid,
              action: msg
            });
          }
        });
      }
    });
  };

  // 액션 구현
  const getEnemies = () => {
    if (!state?.players || !me) return [];
    
    return Object.values(state.players).filter(p => {
      const myT = (me.team === 'A' || me.team === 'team1');
      const t = (p.team === 'A' || p.team === 'team1');
      return t !== myT && p.alive !== false;
    });
  };
  
  const getAllies = () => {
    if (!state?.players || !me) return [];
    
    return Object.values(state.players).filter(p => {
      const myT = (me.team === 'A' || me.team === 'team1');
      const t = (p.team === 'A' || p.team === 'team1');
      return t === myT && p.alive !== false;
    });
  };

  const doAttack = () => {
    const targets = getEnemies();
    if (targets.length === 0) {
      showNotification('공격할 대상이 없습니다!', 'error');
      return;
    }
    showTargets('공격 대상 선택', targets, (t) => {
      sendAction('attack', { targetPid: t.id });
    });
  };
  
  const doDefend = () => sendAction('defend');
  const doEvade = () => sendAction('evade');
  
  const doUseItem = () => {
    const itemsList = ['디터니', '공격 보정기', '방어 보정기'];
    const pick = prompt(`사용할 아이템을 입력하세요:\n${itemsList.join(', ')}`);
    if (!pick) return;
    
    if (pick === '디터니') {
      const targets = getAllies();
      if (targets.length === 0) {
        showNotification('회복 대상이 없습니다!', 'error');
        return;
      }
      showTargets('회복 대상 선택', targets, (t) => {
        sendAction('useItem', { item: '디터니', targetPid: t.id });
      });
    } else if (pick === '공격 보정기' || pick === '방어 보정기') {
      sendAction('useItem', { item: pick, targetPid: myPid });
    } else {
      showNotification('알 수 없는 아이템입니다.', 'error');
    }
  };
  
  const doPass = () => {
    if (confirm('정말로 턴을 넘기시겠습니까?')) {
      sendAction('pass');
    }
  };

  // 채팅 전송
  const sendChat = () => {
    const txt = chatInput.value.trim();
    if (!txt) return;
    
    if (!socket || !socket.connected) {
      showNotification('서버에 연결되어 있지 않습니다', 'error');
      return;
    }
    
    // /t 접두사 처리
    let scope = (chatChannel.value === 'team') ? 'team' : 'all';
    let text = txt;
    if (txt.startsWith('/t ')) {
      scope = 'team';
      text = txt.slice(3).trim();
      if (!text) return;
    }
    
    const nickname = me?.name || '플레이어';
    
    // 1) 신규 스펙
    socket.emit('chat:send', {
      battleId: currentBattleId,
      text,
      nickname,
      role: 'player',
      scope
    }, (ack) => {
      if (ack && ack.ok === false) {
        showNotification(`채팅 오류: ${ack.msg || '전송 실패'}`, 'error');
      }
    });
    
    // 2) 레거시 폴백
    socket.emit('chatMessage', {
      message: text,
      channel: scope === 'team' ? 'team' : 'all'
    });
    
    chatInput.value = '';
  };

  // 이벤트 바인딩
  const setupEventListeners = () => {
    // 액션 버튼
    btnAttack.onclick = doAttack;
    btnDefend.onclick = doDefend;
    btnDodge.onclick = doEvade;
    btnUseItem.onclick = doUseItem;
    btnPass.onclick = doPass;
    
    // 채팅
    chatSend.onclick = sendChat;
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendChat();
    });
    
    // 타겟 선택
    cancelTarget.onclick = hideTargets;

    // 단축키
    document.addEventListener('keydown', (e) => {
      if (targetOverlay.style.display === 'flex') return; // 타겟 선택 중엔 차단
      if (!isMyTurn()) return;
      
      switch (e.key) {
        case '1':
          e.preventDefault();
          doAttack();
          break;
        case '2':
          e.preventDefault();
          doDefend();
          break;
        case '3':
          e.preventDefault();
          doEvade();
          break;
        case '4':
          e.preventDefault();
          doUseItem();
          break;
        case '5':
          e.preventDefault();
          doPass();
          break;
      }
    });

    // 인증 관련
    authJoinBtn.onclick = () => {
      const b = authBattleId.value.trim();
      const t = authToken.value.trim();
      const n = authName.value.trim();
      
      if (!b || !t || !n) {
        authJoinBtn.classList.add('feedback-error');
        setTimeout(() => authJoinBtn.classList.remove('feedback-error'), 1000);
        return showNotification('모든 필드를 입력해주세요!', 'error');
      }
      
      doJoin(b, t, n);
    };

    // 엔터키로 인증
    [authBattleId, authToken, authName].forEach(input => {
      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') authJoinBtn.click();
      });
    });

    // 윈도우 이벤트
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (joined && state) render();
      }, 250);
    });

    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && joined && state) {
        render();
        requestStateUpdate();
      }
    });

    // ESC 키로 타겟 선택 닫기
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && targetOverlay.style.display === 'flex') {
        hideTargets();
      }
    });
  };

  // URL 파라미터 자동 인증
  const initFromUrl = () => {
    const urlParams = new URLSearchParams(location.search);
    const b = urlParams.get('battle');
    const t = urlParams.get('token');
    const n = urlParams.get('name');
    
    if (b && t && n) {
      authBattleId.value = b;
      authToken.value = t;
      authName.value = decodeURIComponent(n);
      
      // 소켓 연결 후 자동 인증
      if (socket && socket.connected) {
        setTimeout(() => doJoin(b, t, n), 500);
      } else {
        socket.on('connect', () => {
          setTimeout(() => doJoin(b, t, n), 500);
        });
      }
    } else {
      authSection.style.display = 'block';
    }
  };

  // 초기화
  const initialize = () => {
    updateConnectionStatus('connecting', '연결 중...');
    
    try {
      initSocket();
      setupEventListeners();
      initFromUrl();
      
      console.log('[Init] Player client initialized');
      
      // 로컬 디버그
      if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
        window.playerDebug = {
          state: () => state,
          socket: () => socket,
          render,
          me: () => me,
          reconnect: initSocket,
          requestState: requestStateUpdate
        };
        console.log('플레이어 디버그 모드: window.playerDebug 사용 가능');
      }
    } catch (error) {
      console.error('[Init] Initialization error:', error);
      showNotification('초기화 중 오류가 발생했습니다', 'error');
    }
  };

  // 페이지 로드 완료 후 초기화
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initialize);
  } else {
    initialize();
  }

  // 정리 함수
  const cleanup = () => {
    if (socket) {
      socket.disconnect();
      socket = null;
    }
    if (reconnectTimer) {
      clearTimeout(reconnectTimer);
      reconnectTimer = null;
    }
    state = null;
    me = null;
    joined = false;
    currentBattleId = null;
  };

  // 페이지 언로드 시 정리
  window.addEventListener('beforeunload', cleanup);
  window.addEventListener('pagehide', cleanup);

  // 전역 오류 처리
  window.addEventListener('error', (event) => {
    console.error('[Global Error]', event.error);
  });

  window.addEventListener('unhandledrejection', (event) => {
    console.error('[Unhandled Promise Rejection]', event.reason);
  });

})();
</script>
</body>
</html>
