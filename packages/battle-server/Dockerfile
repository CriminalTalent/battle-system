import { useState, useEffect, useCallback, useRef } from 'react';
import { io } from 'socket.io-client';
import toast from 'react-hot-toast';

/**
 * ì „íˆ¬ ì‹œìŠ¤í…œ í†µí•© ê´€ë¦¬ í›…
 * 
 * @param {string} battleId - ì „íˆ¬ ID
 * @param {string} token - ì¸ì¦ í† í°
 * @param {Object} options - ì„¤ì • ì˜µì…˜
 */
const useBattle = (battleId, token, options = {}) => {
  // ===========================================
  // ìƒíƒœ ê´€ë¦¬
  // ===========================================
  
  const [battleState, setBattleState] = useState({
    battle: null,
    players: [],
    currentPlayer: null,
    spectators: [],
    battleLog: [],
    gameState: 'waiting', // waiting, active, finished, error
    winner: null,
    error: null
  });

  const [connectionState, setConnectionState] = useState({
    connected: false,
    connecting: false,
    error: null,
    reconnectAttempts: 0
  });

  const [playerState, setPlayerState] = useState({
    playerId: null,
    isSpectator: false,
    isCurrentTurn: false,
    canAct: false,
    selectedAction: null,
    actionCooldown: false
  });

  const [uiState, setUiState] = useState({
    showDamageNumbers: [],
    showBattleLog: true,
    soundEnabled: true,
    animationsEnabled: true,
    compactMode: false
  });

  // ===========================================
  // Refs
  // ===========================================
  
  const socketRef = useRef(null);
  const reconnectTimeoutRef = useRef(null);
  const actionCooldownRef = useRef(null);
  const battleLogRef = useRef(null);

  // ===========================================
  // ì†Œì¼“ ì—°ê²° ê´€ë¦¬
  // ===========================================

  const connectSocket = useCallback(() => {
    if (socketRef.current?.connected) return;

    setConnectionState(prev => ({ ...prev, connecting: true, error: null }));

    const socket = io(process.env.REACT_APP_SOCKET_URL || 'http://localhost:3001', {
      auth: { token },
      query: { battleId },
      transports: ['websocket', 'polling'],
      timeout: 10000,
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
    });

    socketRef.current = socket;

    // ì—°ê²° ì„±ê³µ
    socket.on('connect', () => {
      console.log('ì†Œì¼“ ì—°ê²° ì„±ê³µ:', socket.id);
      setConnectionState({
        connected: true,
        connecting: false,
        error: null,
        reconnectAttempts: 0
      });
      toast.success('ì „íˆ¬ì— ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤!');
    });

    // ì—°ê²° ì‹¤íŒ¨
    socket.on('connect_error', (error) => {
      console.error('ì†Œì¼“ ì—°ê²° ì‹¤íŒ¨:', error);
      setConnectionState(prev => ({
        ...prev,
        connected: false,
        connecting: false,
        error: error.message,
        reconnectAttempts: prev.reconnectAttempts + 1
      }));
      toast.error('ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message);
    });

    // ì—°ê²° ëŠê¹€
    socket.on('disconnect', (reason) => {
      console.log('ì†Œì¼“ ì—°ê²° ëŠê¹€:', reason);
      setConnectionState(prev => ({
        ...prev,
        connected: false,
        connecting: false
      }));
      
      if (reason === 'io server disconnect') {
        toast.error('ì„œë²„ì—ì„œ ì—°ê²°ì„ ëŠì—ˆìŠµë‹ˆë‹¤');
      } else {
        toast.error('ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ìž¬ì—°ê²° ì¤‘...');
      }
    });

    // ìž¬ì—°ê²° ì‹œë„
    socket.on('reconnect', (attemptNumber) => {
      console.log('ìž¬ì—°ê²° ì„±ê³µ:', attemptNumber);
      toast.success('ìž¬ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤!');
    });

    // ìž¬ì—°ê²° ì‹¤íŒ¨
    socket.on('reconnect_failed', () => {
      console.log('ìž¬ì—°ê²° ì‹¤íŒ¨');
      toast.error('ìž¬ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
    });

    return socket;
  }, [battleId, token]);

  // ===========================================
  // ì „íˆ¬ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  // ===========================================

  const setupBattleEvents = useCallback((socket) => {
    // ì „íˆ¬ ìƒíƒœ ì—…ë°ì´íŠ¸
    socket.on('battleUpdate', (data) => {
      console.log('ì „íˆ¬ ì—…ë°ì´íŠ¸:', data);
      setBattleState(prev => ({
        ...prev,
        battle: data.battle,
        players: data.players,
        currentPlayer: data.currentPlayer,
        gameState: data.gameState
      }));
    });

    // í”Œë ˆì´ì–´ ì°¸ê°€
    socket.on('playerJoined', (data) => {
      console.log('í”Œë ˆì´ì–´ ì°¸ê°€:', data);
      setBattleState(prev => ({
        ...prev,
        players: data.players
      }));
      toast.success(`${data.player.name}ë‹˜ì´ ì°¸ê°€í–ˆìŠµë‹ˆë‹¤`);
    });

    // í”Œë ˆì´ì–´ í‡´ìž¥
    socket.on('playerLeft', (data) => {
      console.log('í”Œë ˆì´ì–´ í‡´ìž¥:', data);
      setBattleState(prev => ({
        ...prev,
        players: data.players
      }));
      toast(`${data.player.name}ë‹˜ì´ í‡´ìž¥í–ˆìŠµë‹ˆë‹¤`);
    });

    // í„´ ì‹œìž‘
    socket.on('turnStart', (data) => {
      console.log('í„´ ì‹œìž‘:', data);
      setBattleState(prev => ({
        ...prev,
        currentPlayer: data.currentPlayer
      }));
      
      setPlayerState(prev => ({
        ...prev,
        isCurrentTurn: data.currentPlayer?.id === prev.playerId,
        canAct: data.currentPlayer?.id === prev.playerId
      }));

      if (data.currentPlayer?.id === playerState.playerId) {
        toast('ë‹¹ì‹ ì˜ í„´ìž…ë‹ˆë‹¤!', { icon: 'âš”ï¸' });
      }
    });

    // ì•¡ì…˜ ê²°ê³¼
    socket.on('actionResult', (data) => {
      console.log('ì•¡ì…˜ ê²°ê³¼:', data);
      
      // ì „íˆ¬ ë¡œê·¸ ì¶”ê°€
      setBattleState(prev => ({
        ...prev,
        battleLog: [...prev.battleLog, data.logEntry],
        players: data.players
      }));

      // ë°ë¯¸ì§€ ìˆ«ìž í‘œì‹œ
      if (data.damage > 0) {
        setUiState(prev => ({
          ...prev,
          showDamageNumbers: [
            ...prev.showDamageNumbers,
            {
              id: Date.now(),
              damage: data.damage,
              isCritical: data.isCritical,
              targetId: data.targetId,
              timestamp: Date.now()
            }
          ]
        }));
      }

      // ì‚¬ìš´ë“œ íš¨ê³¼ (ì˜µì…˜)
      if (uiState.soundEnabled && data.soundEffect) {
        playSound(data.soundEffect);
      }
    });

    // ì „íˆ¬ ì¢…ë£Œ
    socket.on('battleEnd', (data) => {
      console.log('ì „íˆ¬ ì¢…ë£Œ:', data);
      setBattleState(prev => ({
        ...prev,
        gameState: 'finished',
        winner: data.winner,
        battleLog: [...prev.battleLog, data.logEntry]
      }));

      if (data.winner) {
        toast.success(`${data.winner.name}ë‹˜ì´ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!`, {
          duration: 5000,
          icon: 'ðŸ†'
        });
      } else {
        toast('ë¬´ìŠ¹ë¶€ìž…ë‹ˆë‹¤!', { icon: 'ðŸ¤' });
      }
    });

    // ì—ëŸ¬ ì²˜ë¦¬
    socket.on('error', (error) => {
      console.error('ì „íˆ¬ ì—ëŸ¬:', error);
      setBattleState(prev => ({
        ...prev,
        error: error.message
      }));
      toast.error(error.message);
    });

    // í”Œë ˆì´ì–´ ì •ë³´ ì„¤ì •
    socket.on('playerInfo', (data) => {
      console.log('í”Œë ˆì´ì–´ ì •ë³´:', data);
      setPlayerState(prev => ({
        ...prev,
        playerId: data.playerId,
        isSpectator: data.isSpectator
      }));
    });

  }, [playerState.playerId, uiState.soundEnabled]);

  // ===========================================
  // ì•¡ì…˜ í•¨ìˆ˜ë“¤
  // ===========================================

  const performAction = useCallback((actionType, target = null) => {
    if (!socketRef.current?.connected) {
      toast.error('ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
      return;
    }

    if (!playerState.canAct) {
      toast.error('ì§€ê¸ˆì€ í–‰ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
      return;
    }

    if (playerState.actionCooldown) {
      toast.error('ìž ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”');
      return;
    }

    console.log('ì•¡ì…˜ ìˆ˜í–‰:', actionType, target);
    
    socketRef.current.emit('playerAction', {
      action: actionType,
      target: target
    });

    // ì•¡ì…˜ ì¿¨ë‹¤ìš´ ì„¤ì •
    setPlayerState(prev => ({ ...prev, actionCooldown: true, canAct: false }));
    
    actionCooldownRef.current = setTimeout(() => {
      setPlayerState(prev => ({ ...prev, actionCooldown: false }));
    }, 1000);

  }, [playerState.canAct, playerState.actionCooldown]);

  const attack = useCallback((target = null) => {
    performAction('attack', target);
  }, [performAction]);

  const defend = useCallback(() => {
    performAction('defend');
  }, [performAction]);

  const surrender = useCallback(() => {
    if (window.confirm('ì •ë§ë¡œ í•­ë³µí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
      performAction('surrender');
    }
  }, [performAction]);

  // ===========================================
  // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
  // ===========================================

  const playSound = useCallback((soundType) => {
    if (!uiState.soundEnabled) return;
    
    // ì‚¬ìš´ë“œ íŒŒì¼ ìž¬ìƒ ë¡œì§ (ì‹¤ì œ êµ¬í˜„ ì‹œ ì¶”ê°€)
    console.log('ì‚¬ìš´ë“œ ìž¬ìƒ:', soundType);
  }, [uiState.soundEnabled]);

  const clearDamageNumber = useCallback((id) => {
    setUiState(prev => ({
      ...prev,
      showDamageNumbers: prev.showDamageNumbers.filter(num => num.id !== id)
    }));
  }, []);

  const toggleBattleLog = useCallback(() => {
    setUiState(prev => ({
      ...prev,
      showBattleLog: !prev.showBattleLog
    }));
  }, []);

  const toggleSound = useCallback(() => {
    setUiState(prev => ({
      ...prev,
      soundEnabled: !prev.soundEnabled
    }));
    toast(uiState.soundEnabled ? 'ì‚¬ìš´ë“œ êº¼ì§' : 'ì‚¬ìš´ë“œ ì¼œì§');
  }, [uiState.soundEnabled]);

  // ===========================================
  // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
  // ===========================================

  useEffect(() => {
    const handleKeyPress = (event) => {
      if (!playerState.canAct) return;

      switch (event.key) {
        case '1':
          event.preventDefault();
          attack();
          break;
        case '2':
          event.preventDefault();
          defend();
          break;
        case 'Tab':
          event.preventDefault();
          toggleBattleLog();
          break;
        default:
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [attack, defend, toggleBattleLog, playerState.canAct]);

  // ===========================================
  // ì´ˆê¸°í™” ë° ì •ë¦¬
  // ===========================================

  useEffect(() => {
    const socket = connectSocket();
    if (socket) {
      setupBattleEvents(socket);
    }

    return () => {
      if (actionCooldownRef.current) {
        clearTimeout(actionCooldownRef.current);
      }
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
      if (socketRef.current) {
        socketRef.current.disconnect();
      }
    };
  }, [connectSocket, setupBattleEvents]);

  // ë°ë¯¸ì§€ ìˆ«ìž ìžë™ ì •ë¦¬
  useEffect(() => {
    const cleanup = setInterval(() => {
      const now = Date.now();
      setUiState(prev => ({
        ...prev,
        showDamageNumbers: prev.showDamageNumbers.filter(
          num => now - num.timestamp < 2000
        )
      }));
    }, 100);

    return () => clearInterval(cleanup);
  }, []);

  // ===========================================
  // ë°˜í™˜ê°’
  // ===========================================

  return {
    // ìƒíƒœ
    ...battleState,
    ...connectionState,
    ...playerState,
    ...uiState,

    // ì•¡ì…˜ í•¨ìˆ˜ë“¤
    attack,
    defend,
    surrender,
    performAction,

    // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
    clearDamageNumber,
    toggleBattleLog,
    toggleSound,
    reconnect: connectSocket,

    // ê³„ì‚°ëœ ê°’ë“¤
    isMyTurn: playerState.isCurrentTurn,
    canPerformAction: playerState.canAct && !playerState.actionCooldown,
    myPlayer: battleState.players.find(p => p.id === playerState.playerId),
    enemyPlayer: battleState.players.find(p => p.id !== playerState.playerId),
  };
};

export default useBattle;
