// packages/battle-server/index.js
const express = require('express');
const { createServer } = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');
const multer = require('multer');

const app = express();
const httpServer = createServer(app);
const io = new Server(httpServer, {
  cors: { origin: "*", methods: ["GET", "POST"] },
  path: "/socket.io",
  pingTimeout: 60000,
  pingInterval: 25000,
  transports: ['websocket', 'polling'],
  allowEIO3: true
});

app.use(cors());
app.use(express.json());

// 업로드 설정
const UPLOAD_DIR = process.env.UPLOAD_DIR || path.join(__dirname, 'uploads');
const MAX_UPLOAD_BYTES = 5 * 1024 * 1024; // 5MB
if (!fs.existsSync(UPLOAD_DIR)) fs.mkdirSync(UPLOAD_DIR, { recursive: true });

const storage = multer.diskStorage({
  destination: (_, __, cb) => cb(null, UPLOAD_DIR),
  filename: (_, file, cb) => {
    const ext = path.extname(file.originalname).toLowerCase();
    const base = crypto.randomBytes(8).toString('hex');
    cb(null, `${Date.now()}_${base}${ext}`);
  }
});
const fileFilter = (_, file, cb) => {
  const ok = ['image/png','image/jpeg','image/webp','image/gif'].includes(file.mimetype);
  if (ok) cb(null, true);
  else cb(new Error('이미지 형식만 허용됩니다'));
};
const upload = multer({ storage, fileFilter, limits: { fileSize: MAX_UPLOAD_BYTES } });

// 정적 파일 서빙
const publicPath = path.join(__dirname, '../battle-web/public');
console.log(`[전투서버] 정적 파일 경로: ${publicPath}`);

const checkFiles = ['admin.html', 'play.html', 'watch.html'];
checkFiles.forEach(file => {
  const filePath = path.join(publicPath, file);
  if (fs.existsSync(filePath)) {
    console.log(`[전투서버] 파일 확인: ${file}`);
  } else {
    console.log(`[전투서버] 파일 누락: ${file} - ${filePath}`);
  }
});

app.use(express.static(publicPath, {
  cacheControl: false,
  setHeaders: (res, filePath) => {
    if (filePath.endsWith('.html')) {
      res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
      res.setHeader('Pragma', 'no-cache');
      res.setHeader('Expires', '0');
    }
  }
}));

// 루트 경로 리다이렉트
app.get('/', (req, res) => {
  res.redirect('/admin.html');
});

// HTML 파일 직접 라우팅
app.get('/admin', (req, res) => {
  res.sendFile(path.join(publicPath, 'admin.html'));
});
app.get('/play', (req, res) => {
  res.sendFile(path.join(publicPath, 'play.html'));
});
app.get('/watch', (req, res) => {
  res.sendFile(path.join(publicPath, 'watch.html'));
});

app.use('/uploads', express.static(UPLOAD_DIR, { fallthrough: true }));

// 저장소 및 상수
const battles = new Map();
const playerSockets = new Map();
const spectatorConnections = new Map();
const adminConnections = new Map();
const connectionHeartbeats = new Map();

const BATTLE_DURATION = 60 * 60 * 1000; // 1시간
const TURN_TIMEOUT = 5 * 60 * 1000;  // 5분
const BASE_HP = 100;
const STAT_MIN = 1;
const STAT_MAX = 10;
const HEARTBEAT_INTERVAL = 30000; // 30초마다 연결 확인

const BATTLE_MODES = {
  '1v1': { teamsCount: 2, playersPerTeam: 1 },
  '2v2': { teamsCount: 2, playersPerTeam: 2 },
  '3v3': { teamsCount: 2, playersPerTeam: 3 },
  '4v4': { teamsCount: 2, playersPerTeam: 4 }
};

const MSG = {
  battle_already_started: '이미 전투가 시작되었습니다.',
  invalid_team: '잘못된 팀입니다.',
  team_full: '해당 팀이 가득 찼습니다.',
  not_enough_players: '플레이어 수가 부족합니다.',
  not_your_teams_turn: '현재 당신의 팀 차례가 아닙니다.',
  player_dead: '해당 플레이어는 이미 사망했습니다.',
  player_already_acted: '이 턴에 이미 행동했습니다.',
  invalid_action: '잘못된 행동 타입입니다.',
  target_not_found: '대상을 찾을 수 없습니다.',
  target_dead: '대상이 이미 사망했습니다.',
  cannot_attack_teammate: '아군은 공격할 수 없습니다.',
  defensive_stance: (name) => `${name}는 방어 태세를 취합니다.`,
  miss: (a, b) => `${a}가 ${b}를 공격했지만 빗나갔습니다!`,
  attack: (a, b, damage, crit, elim) => `${a}가 ${b}에게 ${damage} 피해를 입혔습니다${crit ? ' (치명타)' : ''}${elim ? ' (처치)' : ''}`,
  item_used: (name, item) => `${name}가 ${item}을(를) 사용했습니다.`,
  item_not_found: '보유하지 않은 아이템입니다.',
  dodge_ready: (name) => `${name}는 회피 태세를 취했습니다.`,
  dodge_success: (a, b) => `${b}가 ${a}의 공격을 회피했습니다!`,
  dodge_fail: (a, b) => `${b}의 회피가 실패했습니다.`,
  heal: (name, amount) => `${name}가 ${amount} HP를 회복했습니다.`,
  buff_attack: (name) => `${name}의 공격력이 강화되었습니다.`,
  buff_defense: (name) => `${name}의 방어력이 강화되었습니다.`,
  team_wins: (team) => `${team} 승리!`,
  turn_started: (team) => `${team} 턴이 시작되었습니다.`,
  turn_ended: (team) => `${team} 턴이 종료되었습니다.`,
  battle_timeout: '전투 시간 초과로 무승부입니다.',
  turn_timeout: (name) => `${name}의 턴 시간이 초과되었습니다.`,
  initiative_roll: (team, roll) => `${team} 민첩성 굴림: ${roll}`,
  team_goes_first: (team) => `${team}가 선공합니다!`
};

// 스탯 정규화
function normalizeStats(stats = {}) {
  const out = { ...stats };
  out.attack = Math.min(Math.max(out.attack ?? 3, STAT_MIN), STAT_MAX);
  out.defense = Math.min(Math.max(out.defense ?? 3, STAT_MIN), STAT_MAX);
  out.agility = Math.min(Math.max(out.agility ?? 3, STAT_MIN), STAT_MAX);
  out.luck = Math.min(Math.max(out.luck ?? 3, STAT_MIN), STAT_MAX);
  return out;
}

// 주사위 굴리기 (1-20)
function rollDice() {
  return Math.floor(Math.random() * 20) + 1;
}

// 캐릭터 생성
function createCharacter(playerId, name, stats, teamId, imageUrl = null, items = {}, customHp = null) {
  const maxHp = customHp ? parseInt(customHp) : BASE_HP;
  const normalizedStats = normalizeStats(stats);
  
  // 아이템을 배열로 변환 (각 아이템 개수만큼 배열에 추가)
  const inventory = [];
  if (items['공격 보정기'] > 0) {
    for (let i = 0; i < items['공격 보정기']; i++) {
      inventory.push('공격 보정기');
    }
  }
  if (items['방어 보정기'] > 0) {
    for (let i = 0; i < items['방어 보정기']; i++) {
      inventory.push('방어 보정기');
    }
  }
  if (items['디터니'] > 0) {
    for (let i = 0; i < items['디터니']; i++) {
      inventory.push('디터니');
    }
  }

  return {
    id: playerId,
    name,
    maxHp,
    hp: maxHp,
    stats: normalizedStats,
    teamId,
    imageUrl,
    inventory,
    alive: true,
    hasActed: false,
    defensiveBonus: 0,
    evasionReady: false,
    tempBuffs: {},
    lastAction: null,
    joinedAt: Date.now()
  };
}

// 전투 클래스
class Battle {
  constructor(battleId, mode) {
    this.id = battleId;
    this.mode = mode;
    this.status = 'waiting'; // waiting, ongoing, ended
    this.teams = {
      team1: { players: [], name: '팀 1' },
      team2: { players: [], name: '팀 2' }
    };
    this.currentTeam = 'team1';
    this.currentTurn = 1;
    this.turnTimeoutId = null;
    this.battleTimeoutId = null;
    this.battleLog = [];
    this.chatLog = [];
    this.createdAt = Date.now();
    this.startedAt = null;
    this.endedAt = null;
    this.winner = null;
    this.initiativeRolls = {};
    this.maxPlayers = BATTLE_MODES[mode]?.teamsCount * BATTLE_MODES[mode]?.playersPerTeam || 2;
    this.spectatorCount = 0;
  }

  addPlayer(playerId, name, stats, teamId, imageUrl, items, customHp) {
    if (this.status !== 'waiting') {
      throw new Error(MSG.battle_already_started);
    }

    if (!['team1', 'team2'].includes(teamId)) {
      throw new Error(MSG.invalid_team);
    }

    const team = this.teams[teamId];
    const maxPerTeam = BATTLE_MODES[this.mode]?.playersPerTeam || 1;
    
    if (team.players.length >= maxPerTeam) {
      throw new Error(MSG.team_full);
    }

    // 같은 이름 중복 체크
    const allPlayers = [...this.teams.team1.players, ...this.teams.team2.players];
    if (allPlayers.some(p => p.name === name)) {
      throw new Error('같은 이름의 플레이어가 이미 존재합니다.');
    }

    const character = createCharacter(playerId, name, stats, teamId, imageUrl, items, customHp);
    team.players.push(character);

    this.addLog('system', `${name}님이 ${team.name}에 참가했습니다.`);
    return character;
  }

  // 팀별 민첩성 + 주사위 기반 선공 결정
  rollTeamInitiative() {
    const team1Agility = this.teams.team1.players.reduce((sum, p) => sum + p.stats.agility, 0);
    const team2Agility = this.teams.team2.players.reduce((sum, p) => sum + p.stats.agility, 0);
    
    let team1Roll, team2Roll;
    let attempts = 0;
    
    // 동점시 재굴림
    do {
      team1Roll = team1Agility + rollDice();
      team2Roll = team2Agility + rollDice();
      attempts++;
      
      this.addLog('system', MSG.initiative_roll('팀 1', team1Roll));
      this.addLog('system', MSG.initiative_roll('팀 2', team2Roll));
      
      if (team1Roll === team2Roll && attempts < 5) {
        this.addLog('system', '동점입니다! 다시 굴립니다.');
      }
    } while (team1Roll === team2Roll && attempts < 5);
    
    this.initiativeRolls = { team1: team1Roll, team2: team2Roll };
    
    if (team1Roll >= team2Roll) {
      this.currentTeam = 'team1';
      this.addLog('system', MSG.team_goes_first('팀 1'));
    } else {
      this.currentTeam = 'team2';
      this.addLog('system', MSG.team_goes_first('팀 2'));
    }
  }

  startBattle() {
    const totalPlayers = this.teams.team1.players.length + this.teams.team2.players.length;
    if (totalPlayers < 2) {
      throw new Error(MSG.not_enough_players);
    }

    this.status = 'ongoing';
    this.startedAt = Date.now();
    
    // 선공 결정
    this.rollTeamInitiative();
    
    this.addLog('system', '전투가 시작되었습니다!');
    this.addLog('system', MSG.turn_started(this.teams[this.currentTeam].name));

    // 전투 제한 시간 설정
    this.battleTimeoutId = setTimeout(() => {
      this.endBattle(null, MSG.battle_timeout);
    }, BATTLE_DURATION);

    this.startTurn();
  }

  startTurn() {
    if (this.status !== 'ongoing') return;

    // 이전 턴 정리
    if (this.turnTimeoutId) {
      clearTimeout(this.turnTimeoutId);
    }

    // 현재 팀 플레이어들의 행동 상태 초기화
    this.teams[this.currentTeam].players.forEach(player => {
      player.hasActed = false;
      player.defensiveBonus = 0;
      player.evasionReady = false;
      // 임시 버프 정리
      Object.keys(player.tempBuffs).forEach(buffKey => {
        if (player.tempBuffs[buffKey] <= 0) {
          delete player.tempBuffs[buffKey];
        } else {
          player.tempBuffs[buffKey]--;
        }
      });
    });

    // 턴 제한 시간 설정
    this.turnTimeoutId = setTimeout(() => {
      this.handleTurnTimeout();
    }, TURN_TIMEOUT);
  }

  handleTurnTimeout() {
    this.addLog('system', MSG.turn_timeout(this.teams[this.currentTeam].name));
    this.nextTurn();
  }

  nextTurn() {
    if (this.status !== 'ongoing') return;

    this.addLog('system', MSG.turn_ended(this.teams[this.currentTeam].name));
    
    // 다음 팀으로 전환
    this.currentTeam = this.currentTeam === 'team1' ? 'team2' : 'team1';
    this.currentTurn++;

    // 승리 조건 체크
    if (this.checkWinCondition()) {
      return;
    }

    this.addLog('system', MSG.turn_started(this.teams[this.currentTeam].name));
    this.startTurn();
  }

  checkWinCondition() {
    const team1Alive = this.teams.team1.players.filter(p => p.alive).length;
    const team2Alive = this.teams.team2.players.filter(p => p.alive).length;

    if (team1Alive === 0 && team2Alive === 0) {
      this.endBattle(null, '무승부입니다.');
      return true;
    } else if (team1Alive === 0) {
      this.endBattle('team2', MSG.team_wins(this.teams.team2.name));
      return true;
    } else if (team2Alive === 0) {
      this.endBattle('team1', MSG.team_wins(this.teams.team1.name));
      return true;
    }

    return false;
  }

  endBattle(winner, message) {
    this.status = 'ended';
    this.winner = winner;
    this.endedAt = Date.now();

    if (this.turnTimeoutId) {
      clearTimeout(this.turnTimeoutId);
    }
    if (this.battleTimeoutId) {
      clearTimeout(this.battleTimeoutId);
    }

    this.addLog('system', message);
  }

  // 전투 행동 실행
  executeAction(playerId, action, targetId = null, item = null) {
    if (this.status !== 'ongoing') {
      throw new Error('전투가 진행 중이 아닙니다.');
    }

    const player = this.findPlayer(playerId);
    if (!player) {
      throw new Error('플레이어를 찾을 수 없습니다.');
    }

    if (!player.alive) {
      throw new Error(MSG.player_dead);
    }

    if (player.teamId !== this.currentTeam) {
      throw new Error(MSG.not_your_teams_turn);
    }

    if (player.hasActed) {
      throw new Error(MSG.player_already_acted);
    }

    switch (action) {
      case 'attack':
        return this.executeAttack(player, targetId);
      case 'defend':
        return this.executeDefend(player);
      case 'evade':
        return this.executeEvade(player);
      case 'item':
        return this.executeItem(player, item);
      default:
        throw new Error(MSG.invalid_action);
    }
  }

  executeAttack(attacker, targetId) {
    const target = this.findPlayer(targetId);
    if (!target) {
      throw new Error(MSG.target_not_found);
    }

    if (!target.alive) {
      throw new Error(MSG.target_dead);
    }

    if (target.teamId === attacker.teamId) {
      throw new Error(MSG.cannot_attack_teammate);
    }

    attacker.hasActed = true;
    attacker.lastAction = 'attack';

    // 공격 계산: 공격력 + 주사위(1-20) - 상대 방어력
    const attackPower = attacker.stats.attack + (attacker.tempBuffs.attack || 0);
    const attackRoll = rollDice();
    const totalAttack = attackPower + attackRoll;

    // 명중율 계산: 행운 + 주사위(1-20)
    const hitRoll = attacker.stats.luck + rollDice();

    // 회피율 계산: 민첩성 + 주사위(1-20)
    const evadeRoll = target.stats.agility + rollDice();

    // 회피 체크
    if (target.evasionReady && evadeRoll >= hitRoll) {
      this.addLog('action', MSG.dodge_success(attacker.name, target.name));
      return { success: true, dodged: true };
    } else if (target.evasionReady) {
      this.addLog('action', MSG.dodge_fail(attacker.name, target.name));
    }

    // 일반 명중 체크 (회피 상태가 아닐 때)
    if (!target.evasionReady && hitRoll < evadeRoll) {
      this.addLog('action', MSG.miss(attacker.name, target.name));
      return { success: true, missed: true };
    }

    // 방어력 계산
    const defensePower = target.stats.defense + target.defensiveBonus + (target.tempBuffs.defense || 0);
    let damage = Math.max(1, totalAttack - defensePower);

    // 치명타 계산: 주사위(1-20) >= (20 - 행운/2)
    const critRoll = rollDice();
    const critThreshold = 20 - Math.floor(attacker.stats.luck / 2);
    const isCritical = critRoll >= critThreshold;

    if (isCritical) {
      damage *= 2;
    }

    // 피해 적용
    target.hp = Math.max(0, target.hp - damage);
    if (target.hp === 0) {
      target.alive = false;
    }

    const eliminated = !target.alive;
    this.addLog('action', MSG.attack(attacker.name, target.name, damage, isCritical, eliminated));

    // 승리 조건 체크
    setTimeout(() => this.checkWinCondition(), 100);

    return { 
      success: true, 
      damage, 
      isCritical, 
      eliminated,
      targetHp: target.hp 
    };
  }

  executeDefend(player) {
    player.hasActed = true;
    player.lastAction = 'defend';
    
    // 방어력 2배 보너스
    player.defensiveBonus = player.stats.defense;
    
    this.addLog('action', MSG.defensive_stance(player.name));
    return { success: true };
  }

  executeEvade(player) {
    player.hasActed = true;
    player.lastAction = 'evade';
    player.evasionReady = true;
    
    this.addLog('action', MSG.dodge_ready(player.name));
    return { success: true };
  }

  executeItem(player, itemName) {
    if (!itemName) {
      throw new Error('아이템을 선택해주세요.');
    }

    const itemIndex = player.inventory.indexOf(itemName);
    if (itemIndex === -1) {
      throw new Error(MSG.item_not_found);
    }

    player.hasActed = true;
    player.lastAction = 'item';
    
    // 아이템 사용
    player.inventory.splice(itemIndex, 1);
    
    switch (itemName) {
      case '공격 보정기':
        player.tempBuffs.attack = (player.tempBuffs.attack || 0) + player.stats.attack;
        this.addLog('action', MSG.item_used(player.name, itemName));
        this.addLog('action', MSG.buff_attack(player.name));
        break;
        
      case '방어 보정기':
        player.tempBuffs.defense = (player.tempBuffs.defense || 0) + player.stats.defense;
        this.addLog('action', MSG.item_used(player.name, itemName));
        this.addLog('action', MSG.buff_defense(player.name));
        break;
        
      case '디터니':
        const healAmount = 10;
        player.hp = Math.min(player.maxHp, player.hp + healAmount);
        this.addLog('action', MSG.item_used(player.name, itemName));
        this.addLog('action', MSG.heal(player.name, healAmount));
        break;
        
      default:
        throw new Error('알 수 없는 아이템입니다.');
    }

    return { success: true, item: itemName };
  }

  findPlayer(playerId) {
    for (const team of Object.values(this.teams)) {
      const player = team.players.find(p => p.id === playerId);
      if (player) return player;
    }
    return null;
  }

  addLog(type, message) {
    this.battleLog.push({
      type,
      message,
      timestamp: Date.now(),
      turn: this.currentTurn
    });
  }

  addChatMessage(sender, message, senderType = 'player') {
    const chatEntry = {
      sender,
      message,
      senderType,
      timestamp: Date.now()
    };
    this.chatLog.push(chatEntry);
    return chatEntry;
  }

  getState() {
    return {
      id: this.id,
      mode: this.mode,
      status: this.status,
      teams: this.teams,
      currentTeam: this.currentTeam,
      currentTurn: this.currentTurn,
      battleLog: this.battleLog,
      chatLog: this.chatLog,
      initiativeRolls: this.initiativeRolls,
      maxPlayers: this.maxPlayers,
      winner: this.winner,
      createdAt: this.createdAt,
      startedAt: this.startedAt,
      endedAt: this.endedAt
    };
  }

  // 관전자용 상태 (아이템 정보 숨김)
  getSpectatorState() {
    const state = this.getState();
    // 플레이어 아이템 정보 제거
    ['team1', 'team2'].forEach(teamKey => {
      state.teams[teamKey].players.forEach(player => {
        delete player.inventory;
      });
    });
    return state;
  }
}

// REST API 엔드포인트
app.post('/api/battles', (req, res) => {
  try {
    const battleId = crypto.randomBytes(6).toString('hex').toUpperCase();
    const { mode = '1v1' } = req.body;
    
    if (!BATTLE_MODES[mode]) {
      return res.status(400).json({ error: '지원하지 않는 전투 모드입니다.' });
    }

    const battle = new Battle(battleId, mode);
    battles.set(battleId, battle);
    
    console.log(`[전투서버] 새 전투 생성: ${battleId} (${mode})`);
    
    res.json({ 
      success: true, 
      battleId,
      mode,
      maxPlayers: battle.maxPlayers
    });
  } catch (error) {
    console.error('[전투서버] 전투 생성 실패:', error);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/battles/:id', (req, res) => {
  const battle = battles.get(req.params.id);
  if (!battle) return res.status(404).json({ error: 'Battle not found' });
  res.json({ success: true, state: battle.getState() });
});

app.post('/api/battles/:id/players', upload.single('image'), (req, res) => {
  try {
    const { name, attack = 3, defense = 3, agility = 3, luck = 3, team, hp } = req.body || {};
    const items = {
      '공격 보정기': parseInt(req.body['공격 보정기'] || 0),
      '방어 보정기': parseInt(req.body['방어 보정기'] || 0),
      '디터니': parseInt(req.body['디터니'] || 0)
    };
    
    const battle = battles.get(req.params.id);
    if (!battle) return res.status(404).json({ error: 'Battle not found' });

    const playerId = crypto.randomBytes(4).toString('hex');
    const imageUrl = req.file ? `/uploads/${req.file.filename}` : null;
    const customHp = hp ? parseInt(hp) : null;

    const stats = { attack: parseInt(attack), defense: parseInt(defense), agility: parseInt(agility), luck: parseInt(luck) };
    const character = battle.addPlayer(playerId, name, stats, team, imageUrl, items, customHp);
    
    // 실시간 업데이트
    broadcastBattleUpdate(req.params.id);
    
    res.json({ 
      success: true, 
      playerId,
      character
    });
  } catch (error) {
    console.error('[전투서버] 플레이어 추가 실패:', error);
    res.status(400).json({ error: error.message });
  }
});

app.post('/api/battles/:id/actions', (req, res) => {
  try {
    const { action, playerId, targetId, item } = req.body;
    const battle = battles.get(req.params.id);
    
    if (!battle) return res.status(404).json({ error: 'Battle not found' });
    
    const result = battle.executeAction(playerId, action, targetId, item);
    
    // 실시간 업데이트
    broadcastBattleUpdate(req.params.id);
    
    // 모든 팀원이 행동했는지 체크
    const currentTeamPlayers = battle.teams[battle.currentTeam].players.filter(p => p.alive);
    const actedPlayers = currentTeamPlayers.filter(p => p.hasActed);
    
    if (actedPlayers.length === currentTeamPlayers.length) {
      // 모든 플레이어가 행동했으면 다음 턴으로
      setTimeout(() => {
        battle.nextTurn();
        broadcastBattleUpdate(req.params.id);
      }, 1000);
    }
    
    res.json({ 
      success: true, 
      result,
      battleState: battle.getState()
    });
  } catch (error) {
    console.error('[전투서버] 액션 실행 실패:', error);
    res.status(400).json({ error: error.message });
  }
});

// 관리자 API
app.post('/api/admin/battles/:id/start', (req, res) => {
  try {
    const battle = battles.get(req.params.id);
    if (!battle) return res.status(404).json({ error: 'Battle not found' });
    
    battle.startBattle();
    broadcastBattleUpdate(req.params.id);
    
    res.json({ success: true });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.post('/api/admin/battles/:id/end', (req, res) => {
  try {
    const { winner } = req.body;
    const battle = battles.get(req.params.id);
    if (!battle) return res.status(404).json({ error: 'Battle not found' });
    
    const winnerName = winner ? battle.teams[winner]?.name : null;
    battle.endBattle(winner, winnerName ? MSG.team_wins(winnerName) : '관리자에 의해 종료되었습니다.');
    broadcastBattleUpdate(req.params.id);
    
    res.json({ success: true });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.post('/api/admin/battles/:id/next-turn', (req, res) => {
  try {
    const battle = battles.get(req.params.id);
    if (!battle) return res.status(404).json({ error: 'Battle not found' });
    
    battle.nextTurn();
    broadcastBattleUpdate(req.params.id);
    
    res.json({ success: true });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// 관리자 - 팀에 플레이어 추가 (관리자용)
app.post('/api/admin/battles/:id/add-player', upload.single('image'), (req, res) => {
  try {
    const { name, attack = 3, defense = 3, agility = 3, luck = 3, team, hp } = req.body || {};
    const items = {
      '공격 보정기': parseInt(req.body['공격 보정기'] || 0),
      '방어 보정기': parseInt(req.body['방어 보정기'] || 0),
      '디터니': parseInt(req.body['디터니'] || 0)
    };
    
    const battle = battles.get(req.params.id);
    if (!battle) return res.status(404).json({ error: 'Battle not found' });

    const playerId = crypto.randomBytes(4).toString('hex');
    const imageUrl = req.file ? `/uploads/${req.file.filename}` : null;
    const customHp = hp ? parseInt(hp) : null;

    const stats = { attack: parseInt(attack), defense: parseInt(defense), agility: parseInt(agility), luck: parseInt(luck) };
    const character = battle.addPlayer(playerId, name, stats, team, imageUrl, items, customHp);
    
    // 실시간 업데이트
    broadcastBattleUpdate(req.params.id);
    
    res.json({ 
      success: true, 
      playerId,
      character,
      message: `${name}님이 ${battle.teams[team].name}에 추가되었습니다.`
    });
  } catch (error) {
    console.error('[전투서버] 관리자 플레이어 추가 실패:', error);
    res.status(400).json({ error: error.message });
  }
});

// 관리자 - 플레이어 제거
app.delete('/api/admin/battles/:id/players/:playerId', (req, res) => {
  try {
    const battle = battles.get(req.params.id);
    if (!battle) return res.status(404).json({ error: 'Battle not found' });
    
    const player = battle.findPlayer(req.params.playerId);
    if (!player) return res.status(404).json({ error: 'Player not found' });
    
    // 플레이어 제거
    const team = battle.teams[player.teamId];
    const playerIndex = team.players.findIndex(p => p.id === req.params.playerId);
    if (playerIndex !== -1) {
      team.players.splice(playerIndex, 1);
      battle.addLog('system', `${player.name}님이 제거되었습니다.`);
      
      // 실시간 업데이트
      broadcastBattleUpdate(req.params.id);
      
      res.json({ 
        success: true, 
        message: `${player.name}님이 제거되었습니다.`
      });
    } else {
      res.status(404).json({ error: 'Player not found in team' });
    }
  } catch (error) {
    console.error('[전투서버] 플레이어 제거 실패:', error);
    res.status(400).json({ error: error.message });
  }
});

// 토큰 및 OTP 시스템 (간단화)
const tokens = new Map();
const otps = new Map();

app.post('/api/admin/battles/:id/links', (req, res) => {
  const battleId = req.params.id;
  const adminToken = crypto.randomBytes(16).toString('hex');
  const playerToken = crypto.randomBytes(16).toString('hex');
  const spectatorToken = crypto.randomBytes(16).toString('hex');
  
  tokens.set(adminToken, { type: 'admin', battleId, createdAt: Date.now() });
  tokens.set(playerToken, { type: 'player', battleId, createdAt: Date.now() });
  tokens.set(spectatorToken, { type: 'spectator', battleId, createdAt: Date.now() });
  
  res.json({
    success: true,
    tokens: {
      admin: adminToken,
      player: playerToken,
      spectator: spectatorToken
    }
  });
});

app.post('/api/admin/battles/:id/issue-otp', (req, res) => {
  const { role, playerName } = req.body;
  const otp = Math.random().toString(36).substring(2, 8).toUpperCase();
  
  otps.set(otp, {
    role,
    battleId: req.params.id,
    playerName,
    expiresAt: Date.now() + 10 * 60 * 1000 // 10분
  });
  
  res.json({ success: true, otp });
});

app.post('/api/auth/login', (req, res) => {
  const { battleId, otp, role, playerName } = req.body;
  
  const otpData = otps.get(otp);
  if (!otpData || otpData.expiresAt < Date.now() || otpData.battleId !== battleId || otpData.role !== role) {
    return res.status(401).json({ error: '유효하지 않은 OTP입니다.' });
  }
  
  // OTP 사용 후 삭제
  otps.delete(otp);
  
  const token = crypto.randomBytes(16).toString('hex');
  tokens.set(token, { type: role, battleId, playerName, createdAt: Date.now() });
  
  res.json({ success: true, token });
});p => p.alive);
    const actedPlayers = currentTeamPlayers.filter(p => p.hasActed);
    
    if (actedPlayers.length === currentTeamPlayers.length) {
      // 모든 플레이어가 행동했으면 다음 턴으로
      setTimeout(() => {
        battle.nextTurn();
        broadcastBattleUpdate(req.params.id);
      }, 1000);
    }
    
    res.json({ 
      success: true, 
      result,
      battleState: battle.getState()
    });
  } catch (error) {
    console.error('[전투서버] 액션 실행 실패:', error);
    res.status(400).json({ error: error.message });
  }
});

// 관리자 API
app.post('/api/admin/battles/:id/start', (req, res) => {
  try {
    const battle = battles.get(req.params.id);
    if (!battle) return res.status(404).json({ error: 'Battle not found' });
    
    battle.startBattle();
    broadcastBattleUpdate(req.params.id);
    
    res.json({ success: true });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.post('/api/admin/battles/:id/end', (req, res) => {
  try {
    const { winner } = req.body;
    const battle = battles.get(req.params.id);
    if (!battle) return res.status(404).json({ error: 'Battle not found' });
    
    const winnerName = winner ? battle.teams[winner]?.name : null;
    battle.endBattle(winner, winnerName ? MSG.team_wins(winnerName) : '관리자에 의해 종료되었습니다.');
    broadcastBattleUpdate(req.params.id);
    
    res.json({ success: true });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.post('/api/admin/battles/:id/next-turn', (req, res) => {
  try {
    const battle = battles.get(req.params.id);
    if (!battle) return res.status(404).json({ error: 'Battle not found' });
    
    battle.nextTurn();
    broadcastBattleUpdate(req.params.id);
    
    res.json({ success: true });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// 토큰 및 OTP 시스템 (간단화)
const tokens = new Map();
const otps = new Map();

app.post('/api/admin/battles/:id/links', (req, res) => {
  const battleId = req.params.id;
  const adminToken = crypto.randomBytes(16).toString('hex');
  const playerToken = crypto.randomBytes(16).toString('hex');
  const spectatorToken = crypto.randomBytes(16).toString('hex');
  
  tokens.set(adminToken, { type: 'admin', battleId });
  tokens.set(playerToken, { type: 'player', battleId });
  tokens.set(spectatorToken, { type: 'spectator', battleId });
  
  res.json({
    success: true,
    tokens: {
      admin: adminToken,
      player: playerToken,
      spectator: spectatorToken
    }
  });
});

app.post('/api/admin/battles/:id/issue-otp', (req, res) => {
  const { role, playerName } = req.body;
  const otp = Math.random().toString(36).substring(2, 8).toUpperCase();
  
  otps.set(otp, {
    role,
    battleId: req.params.id,
    playerName,
    expiresAt: Date.now() + 10 * 60 * 1000 // 10분
  });
  
  res.json({ success: true, otp });
});

app.post('/api/auth/login', (req, res) => {
  const { battleId, otp, role, playerName } = req.body;
  
  const otpData = otps.get(otp);
  if (!otpData || otpData.expiresAt < Date.now() || otpData.battleId !== battleId || otpData.role !== role) {
    return res.status(401).json({ error: '유효하지 않은 OTP입니다.' });
  }
  
  // OTP 사용 후 삭제
  otps.delete(otp);
  
  const token = crypto.randomBytes(16).toString('hex');
  tokens.set(token, { type: role, battleId, playerName });
  
  res.json({ success: true, token });
});

// 실시간 업데이트 함수
function broadcastBattleUpdate(battleId) {
  const battle = battles.get(battleId);
  if (!battle) return;
  
  const state = battle.getState();
  const spectatorState = battle.getSpectatorState();
  
  // 플레이어와 관리자에게 전체 상태 전송
  io.to(`battle_${battleId}_players`).emit('battle-state', { battleId, state });
  io.to(`battle_${battleId}_admin`).emit('battle-state', { battleId, state });
  
  // 관전자에게는 아이템 정보 제외한 상태 전송
  io.to(`battle_${battleId}_spectators`).emit('battle-state', { battleId, state: spectatorState });
  
  // 연결된 모든 클라이언트에게 업데이트
  io.to(battleId).emit('battle-update', { battleId, state: spectatorState });
}

function broadcastToRoom(battleId, event, data) {
  io.to(battleId).emit(event, { battleId, ...data });
}

// Socket.IO 연결 처리
io.on('connection', (socket) => {
  console.log(`[전투서버] 소켓 연결: ${socket.id}`);
  
  // 연결 상태 추적
  connectionHeartbeats.set(socket.id, Date.now());
  
  // 하트비트 응답
  socket.on('heartbeat', () => {
    connectionHeartbeats.set(socket.id, Date.now());
    socket.emit('heartbeat-ack', { timestamp: Date.now() });
  });

  // 관리자 연결
  socket.on('join-admin', (data) => {
    const { battleId, token } = data || {};
    if (!battleId) return;
    
    socket.join(battleId);
    socket.join(`battle_${battleId}_admin`);
    socket.battleId = battleId;
    socket.role = 'admin';
    
    adminConnections.set(socket.id, { battleId });
    
    console.log(`[전투서버] 관리자 연결: ${socket.id} -> ${battleId}`);
    
    // 현재 상태 전송
    const battle = battles.get(battleId);
    if (battle) {
      socket.emit('battle-state', { battleId, state: battle.getState() });
    }
  });

  // 플레이어 연결
  socket.on('join-player', (data) => {
    const { battleId, playerId, name } = data || {};
    if (!battleId || !playerId) return;
    
    socket.join(battleId);
    socket.join(`battle_${battleId}_players`);
    socket.battleId = battleId;
    socket.playerId = playerId;
    socket.userName = name;
    socket.role = 'player';
    
    playerSockets.set(socket.id, { battleId, playerId, name });
    
    console.log(`[전투서버] 플레이어 연결: ${socket.id} (${name}) -> ${battleId}`);
    
    // 현재 상태 전송
    const battle = battles.get(battleId);
    if (battle) {
      socket.emit('battle-state', { battleId, state: battle.getState() });
      
      // 다른 플레이어들에게 연결 알림
      socket.to(battleId).emit('player-connected', { 
        playerId, 
        name,
        message: `${name}님이 연결되었습니다.`
      });
    }
  });

  // 관전자 연결
  socket.on('join-spectator', (data) => {
    const { battleId, name } = data || {};
    if (!battleId) return;
    
    socket.join(battleId);
    socket.join(`battle_${battleId}_spectators`);
    socket.battleId = battleId;
    socket.userName = name || '익명';
    socket.role = 'spectator';
    
    if (!spectatorConnections.has(battleId)) {
      spectatorConnections.set(battleId, new Set());
    }
    spectatorConnections.get(battleId).add(socket.id);
    
    const battle = battles.get(battleId);
    if (battle) {
      battle.spectatorCount = spectatorConnections.get(battleId).size;
      
      console.log(`[전투서버] 관전자 연결: ${socket.id} (${socket.userName}) -> ${battleId}`);
      
      // 관전자용 상태 전송
      socket.emit('battle-state', { battleId, state: battle.getSpectatorState() });
      
      // 관전자 입장 알림
      socket.to(battleId).emit('spectator-joined', {
        name: socket.userName,
        count: battle.spectatorCount,
        message: `관전자 ${socket.userName}님이 입장했습니다.`
      });
      
      // 관전자 수 업데이트
      broadcastBattleUpdate(battleId);
    }
  });

  // 채팅 메시지
  socket.on('send-chat', (data) => {
    const { battleId, message, senderType = 'player' } = data || {};
    const battle = battles.get(battleId);
    
    if (!battle || !message || message.length > 200) return;
    
    // 메시지 필터링 (기본적인 욕설 필터)
    const filteredMessage = message.replace(/[욕설패턴]/g, '***');
    
    const chatEntry = battle.addChatMessage(socket.userName || '익명', filteredMessage, senderType);
    
    // 실시간 채팅 전송
    io.to(battleId).emit('chat-message', { battleId, message: chatEntry });
    
    console.log(`[전투서버] 채팅: ${socket.userName} -> ${filteredMessage}`);
  });

  // 액션 실행 (소켓을 통한 실시간 처리)
  socket.on('execute-action', (data) => {
    try {
      const { battleId, action, playerId, targetId, item } = data;
      const battle = battles.get(battleId);
      
      if (!battle) {
        socket.emit('error', { message: 'Battle not found' });
        return;
      }
      
      const result = battle.executeAction(playerId, action, targetId, item);
      
      // 액션 결과를 실시간으로 모든 참가자에게 전송
      broadcastToRoom(battleId, 'action-result', {
        playerId,
        action,
        result,
        timestamp: Date.now()
      });
      
      // 전투 상태 업데이트
      broadcastBattleUpdate(battleId);
      
      // 모든 팀원이 행동했는지 체크
      const currentTeamPlayers = battle.teams[battle.currentTeam].players.filter(p => p.alive);
      const actedPlayers = currentTeamPlayers.filter(p => p.hasActed);
      
      if (actedPlayers.length === currentTeamPlayers.length) {
        setTimeout(() => {
          battle.nextTurn();
          broadcastBattleUpdate(battleId);
          
          // 턴 변경 알림
          broadcastToRoom(battleId, 'turn-changed', {
            newTeam: battle.currentTeam,
            turn: battle.currentTurn,
            message: MSG.turn_started(battle.teams[battle.currentTeam].name)
          });
        }, 1500); // 1.5초 딜레이로 결과 확인 시간 제공
      }
      
    } catch (error) {
      console.error('[전투서버] 액션 실행 실패:', error);
      socket.emit('error', { message: error.message });
    }
  });

  // 연결 상태 확인 요청
  socket.on('ping', () => {
    socket.emit('pong', { timestamp: Date.now() });
  });

  // 실시간 상태 동기화
  socket.on('sync-state', (data) => {
    const { battleId } = data || {};
    const battle = battles.get(battleId);
    
    if (battle) {
      if (socket.role === 'spectator') {
        socket.emit('battle-state', { battleId, state: battle.getSpectatorState() });
      } else {
        socket.emit('battle-state', { battleId, state: battle.getState() });
      }
    }
  });

  // 연결 해제 처리
  socket.on('disconnect', () => {
    console.log(`[전투서버] 소켓 연결 해제: ${socket.id}`);
    
    connectionHeartbeats.delete(socket.id);
    
    const battleId = socket.battleId;
    
    // 플레이어 소켓 정리
    if (playerSockets.has(socket.id)) {
      const playerInfo = playerSockets.get(socket.id);
      playerSockets.delete(socket.id);
      
      if (battleId) {
        socket.to(battleId).emit('player-disconnected', {
          playerId: socket.playerId,
          name: socket.userName,
          message: `${socket.userName}님이 연결을 해제했습니다.`
        });
      }
    }
    
    // 관전자 소켓 정리
    if (battleId && spectatorConnections.has(battleId)) {
      const spectators = spectatorConnections.get(battleId);
      if (spectators.has(socket.id)) {
        spectators.delete(socket.id);
        
        if (spectators.size === 0) {
          spectatorConnections.delete(battleId);
        }
        
        const battle = battles.get(battleId);
        if (battle) {
          battle.spectatorCount = spectators.size;
          
          socket.to(battleId).emit('spectator-left', {
            name: socket.userName,
            count: battle.spectatorCount,
            message: `관전자 ${socket.userName}님이 퇴장했습니다.`
          });
          
          broadcastBattleUpdate(battleId);
        }
      }
    }
    
    // 관리자 소켓 정리
    if (adminConnections.has(socket.id)) {
      adminConnections.delete(socket.id);
    }
  });
});

// 주기적 정리 작업
setInterval(() => {
  const now = Date.now();
  
  // 만료된 OTP 정리
  for (const [otp, data] of otps.entries()) {
    if (data.expiresAt < now) {
      otps.delete(otp);
    }
  }
  
  // 오래된 토큰 정리 (24시간)
  for (const [token, data] of tokens.entries()) {
    if (now - data.createdAt > 24 * 60 * 60 * 1000) {
      tokens.delete(token);
    }
  }
  
  // 비활성 연결 정리
  for (const [socketId, lastHeartbeat] of connectionHeartbeats.entries()) {
    if (now - lastHeartbeat > 2 * HEARTBEAT_INTERVAL) {
      connectionHeartbeats.delete(socketId);
      // 소켓 강제 해제는 Socket.IO가 자동으로 처리
    }
  }
  
  // 오래된 전투 정리 (24시간)
  for (const [battleId, battle] of battles.entries()) {
    if (now - battle.createdAt > 24 * 60 * 60 * 1000) {
      battles.delete(battleId);
      console.log(`[전투서버] 오래된 전투 삭제: ${battleId}`);
    }
  }
  
}, 60000); // 1분마다 실행

// 하트비트 시스템
setInterval(() => {
  io.emit('heartbeat-request', { timestamp: Date.now() });
}, HEARTBEAT_INTERVAL);

// 서버 시작
const PORT = process.env.PORT || 3001;
httpServer.listen(PORT, () => {
  console.log(`[전투서버] 서버 시작됨 - 포트 ${PORT}`);
  console.log(`[전투서버] 관리자 페이지: http://localhost:${PORT}/admin`);
  console.log(`[전투서버] 플레이어 페이지: http://localhost:${PORT}/play`);
  console.log(`[전투서버] 관전자 페이지: http://localhost:${PORT}/watch`);
  console.log('[전투서버] 실시간 스트리밍 시스템 활성화');
});

// 우아한 종료 처리
process.on('SIGTERM', () => {
  console.log('[전투서버] SIGTERM 신호 수신, 서버 종료 중...');
  
  // 모든 진행 중인 전투 종료
  for (const [battleId, battle] of battles.entries()) {
    if (battle.status === 'ongoing') {
      battle.endBattle(null, '서버 점검으로 인한 전투 종료');
      broadcastBattleUpdate(battleId);
    }
  }
  
  // 소켓 연결 정리
  io.emit('server-shutdown', { message: '서버 점검이 시작됩니다.' });
  
  setTimeout(() => {
    httpServer.close(() => {
      console.log('[전투서버] 서버 종료 완료');
      process.exit(0);
    });
  }, 5000);
});

process.on('SIGINT', () => {
  console.log('[전투서버] SIGINT 신호 수신, 서버 종료 중...');
  process.exit(0);
});
